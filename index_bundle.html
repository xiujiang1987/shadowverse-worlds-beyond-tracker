<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>闇影詩章：凌越世界 (Shadowverse: Worlds Beyond) - 對戰紀錄APP</title>
    <style>
/* Shadowverse: Worlds Beyond Tracker - 主樣式文件 */

/* 基礎重置與全域樣式 */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Microsoft JhengHei', Arial, sans-serif;
    background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
    color: #fff;
    min-height: 100vh;
    padding: 20px;
}

/* 容器與佈局 */
.container {
    max-width: 800px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 15px;
    padding: 30px;
    backdrop-filter: blur(10px);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

/* 頭部區域 */
.header {
    text-align: center;
    margin-bottom: 30px;
}

.header h1 {
    color: #ffd700;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
    margin-bottom: 10px;
}

/* 導航選單 */
.nav-menu {
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-top: 20px;
    flex-wrap: wrap;
}

.nav-btn {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 215, 0, 0.3);
    padding: 10px 20px;
    border-radius: 25px;
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    text-decoration: none;
}

.nav-btn:hover {
    background: rgba(255, 215, 0, 0.2);
    border-color: #ffd700;
    transform: translateY(-2px);
}

.nav-btn.active {
    background: linear-gradient(45deg, #ffd700, #ffb300);
    border-color: #ffd700;
    color: #000;
}

/* 面板系統 */
.panel {
    display: none;
}

.panel.active {
    display: block;
}

/* 統計面板 */
.stats-panel {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin-bottom: 30px;
}

.stat-card {
    background: rgba(255, 255, 255, 0.15);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.stat-title {
    font-size: 14px;
    color: #ccc;
    margin-bottom: 10px;
}

.stat-value {
    font-size: 24px;
    font-weight: bold;
    color: #ffd700;
}

/* 玩家資料面板 */
.player-profile {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 25px;
    margin-bottom: 30px;
}

.profile-section {
    margin-bottom: 25px;
}

.profile-section h3 {
    color: #ffd700;
    margin-bottom: 15px;
    border-bottom: 2px solid rgba(255, 215, 0, 0.3);
    padding-bottom: 10px;
}

.profile-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
}

.profile-item {
    background: rgba(255, 255, 255, 0.15);
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid #ffd700;
}

.profile-label {
    color: #ccc;
    font-size: 14px;
    margin-bottom: 5px;
}

.profile-value {
    color: #fff;
    font-size: 16px;
    font-weight: bold;
}

.profile-value.editable {
    cursor: pointer;
    transition: all 0.3s;
}

.profile-value.editable:hover {
    color: #ffd700;
    transform: scale(1.05);
}

/* 表單元素 */
.battle-form {
    background: rgba(255, 255, 255, 0.1);
    padding: 25px;
    border-radius: 10px;
    margin-bottom: 30px;
}

.form-group {
    margin-bottom: 20px;
}

.form-group label {
    display: block;
    margin-bottom: 8px;
    color: #ffd700;
    font-weight: bold;
}

.form-group select, .form-group input {
    width: 100%;
    padding: 12px;
    border: none;
    border-radius: 8px;
    background: rgba(255, 255, 255, 0.2);
    color: #fff;
    font-size: 16px;
    transition: all 0.3s ease;
}

.form-group select:focus, .form-group input:focus {
    outline: none;
    background: rgba(255, 255, 255, 0.3);
    box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}

/* 輸入驗證樣式 */
.form-group input.error {
    border: 2px solid #ff4444;
    background: rgba(255, 68, 68, 0.2);
    animation: shake 0.5s ease-in-out;
}

.form-group input.warning {
    border: 2px solid #ffa500;
    background: rgba(255, 165, 0, 0.2);
}

.form-group input.success {
    border: 2px solid #4caf50;
    background: rgba(76, 175, 80, 0.2);
}

/* 搖動動畫 */
@keyframes shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    75% { transform: translateX(5px); }
}

/* Toast 通知樣式 */
.toast {
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 15px 20px;
    border-radius: 8px;
    color: white;
    font-weight: bold;
    z-index: 1000;
    transform: translateX(300px);
    transition: transform 0.3s ease;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
}

.toast.show {
    transform: translateX(0);
}

.toast-success {
    background: linear-gradient(45deg, #4caf50, #8bc34a);
}

.toast-error {
    background: linear-gradient(45deg, #f44336, #ff6b6b);
}

.toast-warning {
    background: linear-gradient(45deg, #ff9800, #ffc107);
}

.toast-info {
    background: linear-gradient(45deg, #2196f3, #03a9f4);
}

.form-group select option {
    background: #1a1a2e;
    color: #fff;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap: 15px;
}

/* 按鈕樣式 */
.btn {
    background: linear-gradient(45deg, #ff6b6b, #ffd700);
    border: none;
    padding: 15px 30px;
    border-radius: 25px;
    color: #fff;
    font-size: 16px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    margin-top: 20px;
}

.btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
}

.clear-btn {
    background: linear-gradient(45deg, #666, #999);
    margin-top: 10px;
}

.export-btn {
    background: linear-gradient(45deg, #00bcd4, #4dd0e1);
    margin-top: 10px;
}

.import-btn {
    background: linear-gradient(45deg, #ff9800, #ffb74d);
    margin-top: 10px;
}

/* 對戰歷史 */
.battle-history {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    max-height: 400px;
    overflow-y: auto;
}

.battle-item {
    padding: 15px 20px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
}

.battle-item:last-child {
    border-bottom: none;
}

.battle-info {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
}

.battle-result {
    padding: 5px 15px;
    border-radius: 15px;
    font-weight: bold;
    margin-left: 15px;
}

.win {
    background: linear-gradient(45deg, #4CAF50, #81C784);
}

.lose {
    background: linear-gradient(45deg, #f44336, #e57373);
}

.bp-change {
    color: #ffd700;
    font-weight: bold;
}

/* 先手後手樣式 */
.turn-order {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 8px;
    font-size: 11px;
    font-weight: bold;
    margin: 0 4px;
}

.turn-order.先手 {
    background: linear-gradient(45deg, #FF6B6B, #FF8E53);
    color: white;
}

.turn-order.後手 {
    background: linear-gradient(45deg, #4ECDC4, #44A08D);
    color: white;
}

/* 職業圖標 */
.职业-icon {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 12px;
    margin-right: 8px;
}

.皇家 { background: #FFD700; color: #000; }
.精靈 { background: #228B22; color: #fff; }
.巫師 { background: #4169E1; color: #fff; }
.龍 { background: #DC143C; color: #fff; }
.夜魔 { background: linear-gradient(45deg, #8B008B, #8B0000); color: #fff; }
.主教 { background: #F0E68C; color: #000; }
.復仇者 { background: #2F4F4F; color: #fff; }

/* 階級計算器 */
.rank-calculator {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 25px;
    margin: 20px 0;
}

.rank-info {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.rank-card {
    background: rgba(255, 255, 255, 0.15);
    padding: 15px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
}

.rank-title {
    color: #ffd700;
    font-weight: bold;
    margin-bottom: 10px;
}

.rank-requirement {
    color: #ccc;
    font-size: 14px;
    line-height: 1.4;
}

.rank-status {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 8px;
    margin-top: 15px;
}

.progress-bar {
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    height: 20px;
    margin: 10px 0;
    overflow: hidden;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(45deg, #4CAF50, #81C784);
    transition: width 0.3s ease;
}

.rank-danger {
    color: #ff6b6b;
}

.rank-safe {
    color: #4CAF50;
}

.rank-warning {
    color: #ffa726;
}

/* 數據同步功能 */
.sync-section {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
    border: 2px solid rgba(255, 215, 0, 0.3);
}

.sync-buttons {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
    margin-bottom: 20px;
}

.sync-btn {
    background: linear-gradient(45deg, #4CAF50, #81C784);
    border: none;
    padding: 15px 20px;
    border-radius: 10px;
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
}

.sync-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
}

.sync-btn.screenshot {
    background: linear-gradient(45deg, #2196F3, #64B5F6);
}

.sync-btn.voice {
    background: linear-gradient(45deg, #FF9800, #FFB74D);
}

.sync-btn.quick {
    background: linear-gradient(45deg, #9C27B0, #BA68C8);
}

/* 匯入區域 */
.import-area {
    background: rgba(255, 255, 255, 0.1);
    border: 2px dashed rgba(255, 255, 255, 0.3);
    border-radius: 10px;
    padding: 20px;
    margin: 20px 0;
    text-align: center;
    transition: all 0.3s ease;
}

.import-area:hover {
    border-color: #ffd700;
    background: rgba(255, 215, 0, 0.1);
}

.import-area.dragover {
    border-color: #4CAF50;
    background: rgba(76, 175, 80, 0.2);
}

.file-input {
    display: none;
}

/* 對戰矩陣樣式 */
.matrix-container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

.matrix-toggle {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 30px;
}

.matrix-btn {
    padding: 12px 24px;
    border: 2px solid #444;
    background: rgba(0, 0, 0, 0.3);
    color: #ccc;
    border-radius: 25px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: bold;
}

.matrix-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: #666;
}

.matrix-btn.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-color: #667eea;
    color: white;
}

.matrix-table-container {
    display: none;
    margin-bottom: 30px;
}

.matrix-table-container.active {
    display: block;
}

.matrix-table {
    margin-bottom: 25px;
    overflow-x: auto;
}

.matrix-table-content {
    width: 100%;
    border-collapse: collapse;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 10px;
    overflow: hidden;
    min-width: 700px;
}

.matrix-table-content th,
.matrix-table-content td {
    padding: 10px 8px;
    text-align: center;
    border: 1px solid #444;
    font-size: 13px;
}

.matrix-header-corner {
    background: linear-gradient(135deg, #434343 0%, #000000 100%);
    color: #ffd700;
    font-weight: bold;
    position: sticky;
    left: 0;
    z-index: 3;
}

.matrix-header {
    background: linear-gradient(135deg, #434343 0%, #2c2c2c 100%);
    color: #ffd700;
    font-weight: bold;
    writing-mode: vertical-rl;
    text-orientation: mixed;
    min-width: 45px;
}

.matrix-row-header {
    background: linear-gradient(135deg, #434343 0%, #2c2c2c 100%);
    color: #ffd700;
    font-weight: bold;
    position: sticky;
    left: 0;
    z-index: 2;
    min-width: 80px;
}

.matrix-cell {
    background: rgba(0, 0, 0, 0.3);
    color: #ccc;
    transition: all 0.3s ease;
    cursor: help;
    min-width: 45px;
}

.matrix-cell:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.05);
}

.high-winrate {
    background: rgba(76, 175, 80, 0.3) !important;
    color: #4CAF50 !important;
    font-weight: bold;
}

.medium-winrate {
    background: rgba(255, 193, 7, 0.3) !important;
    color: #FFC107 !important;
    font-weight: bold;
}

.low-winrate {
    background: rgba(244, 67, 54, 0.3) !important;
    color: #F44336 !important;
    font-weight: bold;
}

.matrix-stats {
    background: rgba(0, 0, 0, 0.4);
    border-radius: 10px;
    padding: 20px;
    margin-top: 20px;
}

.matrix-stats-content h4 {
    color: #ffd700;
    margin-bottom: 15px;
    text-align: center;
}

.matrix-stats-content p {
    color: #ccc;
    text-align: center;
    font-size: 16px;
    margin-bottom: 20px;
}

.matchup-section {
    margin-bottom: 20px;
}

.matchup-section h5 {
    margin-bottom: 10px;
}

.matchup-section ul {
    list-style: none;
    padding: 0;
}

.matchup-section li {
    padding: 5px 0;
    color: #ccc;
    border-bottom: 1px solid #333;
}

.matchup-section li:last-child {
    border-bottom: none;
}

.matrix-info {
    background: rgba(0, 0, 0, 0.4);
    border-radius: 10px;
    padding: 20px;
    margin-top: 30px;
}

.matrix-info ul {
    list-style: none;
    padding: 0;
}

.matrix-info li {
    padding: 8px 0;
    border-bottom: 1px solid #333;
}

.matrix-info li:last-child {
    border-bottom: none;
}

/* 響應式設計 */
@media (max-width: 768px) {
    .nav-menu {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    
    .nav-btn {
        font-size: 12px;
        padding: 8px 16px;
    }
    
    .matrix-toggle {
        flex-direction: column;
        align-items: center;
    }
    
    .matrix-btn {
        width: 80%;
        max-width: 300px;
    }
    
    .matrix-table {
        font-size: 12px;
    }
    
    .matrix-table-content th,
    .matrix-table-content td {
        padding: 6px 4px;
        font-size: 11px;
    }
    
    .matrix-header {
        writing-mode: horizontal-tb;
        text-orientation: initial;
        min-width: 35px;
    }
}

/* 動畫效果 */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

/* 分組變動標記按鈕 */
.rank-change-btn {
    background: transparent;
    border: none;
    font-size: 16px;
    cursor: pointer;
    padding: 4px 8px;
    margin-left: 10px;
    border-radius: 4px;
    transition: all 0.3s ease;
    opacity: 0.6;
}

.rank-change-btn:hover {
    opacity: 1;
    background: rgba(255, 255, 255, 0.1);
    transform: scale(1.1);
}

.rank-change-btn.marked {
    opacity: 1;
    background: rgba(255, 193, 7, 0.2);
    border: 1px solid #FFC107;
}

/* 對戰記錄編輯按鈕 */
.battle-actions {
    display: flex;
    align-items: center;
    gap: 5px;
    margin-left: auto;
}

.edit-btn, .delete-btn {
    background: transparent;
    border: none;
    font-size: 14px;
    cursor: pointer;
    padding: 4px 6px;
    border-radius: 4px;
    transition: all 0.3s ease;
    opacity: 0.6;
}

.edit-btn:hover {
    opacity: 1;
    background: rgba(33, 150, 243, 0.2);
    transform: scale(1.1);
}

.delete-btn:hover {
    opacity: 1;
    background: rgba(244, 67, 54, 0.2);
    transform: scale(1.1);
}

.battle-item {
    position: relative;
}

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🃏 闇影詩章：凌越世界 (Shadowverse: Worlds Beyond)</h1>
            <p>對戰紀錄追蹤系統</p>
            
            <!-- 導航選單 -->
            <div class="nav-menu">
                <button class="nav-btn active" onclick="showPanel('stats')">📊 對戰統計</button>
                <button class="nav-btn" onclick="showPanel('matrix')">🎯 對戰矩陣</button>
                <button class="nav-btn" onclick="showPanel('player')">👤 玩家資料</button>
                <button class="nav-btn" onclick="showPanel('battle')">⚔️ 對戰記錄</button>
                <button class="nav-btn" onclick="showPanel('settings')">⚙️ 設定匯入</button>
            </div>
        </div>
        
        <!-- 對戰統計面板 -->
        <div id="statsPanel" class="panel active">
            <div class="stats-panel">
                <div class="stat-card">
                    <div class="stat-title">起始分組</div>
                    <div class="stat-value" id="currentRank" style="cursor: pointer; transition: all 0.3s; font-size: 20px;" onclick="editCurrentRank()"></div>
                    <small style="color: #ccc; font-size: 12px;">點擊編輯</small>
                </div>
                <div class="stat-card">
                    <div class="stat-title">起始BP</div>
                    <div class="stat-value" id="startingBP" style="cursor: pointer; transition: all 0.3s;" onclick="editStartingBP()">43945</div>
                    <small style="color: #ccc; font-size: 12px;">點擊編輯</small>
                </div>
                <div class="stat-card">
                    <div class="stat-title">目前BP</div>
                    <div class="stat-value" id="currentBP">45427</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">目前階級</div>
                    <div class="stat-value" id="currentRankLevel">A1</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">總對戰場數</div>
                    <div class="stat-value" id="totalGames">10</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">總勝率</div>
                    <div class="stat-value" id="winRate">60%</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">先手勝率</div>
                    <div class="stat-value" id="firstWinRate">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">後手勝率</div>
                    <div class="stat-value" id="secondWinRate">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-title">連勝/連敗</div>
                    <div class="stat-value" id="streak">1敗</div>
                </div>
            </div>
            
            <div class="rank-calculator">
                <h3 style="color: #ffd700; margin-bottom: 20px;">🏆 分組升降計算器</h3>
                <div class="rank-info">
                    <div class="rank-card" style="border-left: 8px solid #4caf50;">
                        <div class="rank-title">🟢 綠寶石分組 <span style='color:#4caf50'>(x1.0)</span></div>
                        <div class="rank-requirement">• 新手分組<br>• 升級條件：達到一定BP自動升級<br>• 勝率無壓力，倍率x1.0</div>
                    </div>
                    <div class="rank-card" style="border-left: 8px solid #ffb300;">
                        <div class="rank-title">🟠 黃寶石分組 <span style='color:#ffb300'>(x1.1)</span></div>
                        <div class="rank-requirement">• 進階分組<br>• 升級條件：BP達標自動升級<br>• 勝率建議45%以上，倍率x1.1</div>
                    </div>
                    <div class="rank-card" style="border-left: 8px solid #e53935;">
                        <div class="rank-title">🔴 紅寶石分組 <span style='color:#e53935'>(x1.3)</span></div>
                        <div class="rank-requirement">• 中高級分組<br>• 升級條件：BP達標自動升級<br>• 勝率建議50%以上，倍率x1.3</div>
                    </div>
                    <div class="rank-card" style="border-left: 8px solid #1e88e5;">
                        <div class="rank-title">🔵 藍寶石分組 <span style='color:#1e88e5'>(x1.5)</span></div>
                        <div class="rank-requirement">• 高級分組<br>• 升級條件：BP達標自動升級<br>• 勝率建議55%以上，倍率x1.5</div>
                    </div>
                    <div class="rank-card" style="border-left: 8px solid #b39ddb;">
                        <div class="rank-title">💎 鑽石分組 <span style='color:#b39ddb'>(x2.0)</span></div>
                        <div class="rank-requirement">• 最高分組<br>• 維持條件：勝率60%以上<br>• 低於50%有掉級風險，倍率x2.0</div>
                    </div>
                </div>
                
                <div class="rank-status">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <span><strong>目前狀態分析：</strong></span>
                        <span id="rankStatusText" class="rank-safe">✅ 分組安全</span>
                    </div>
                    
                    <div class="progress-bar">
                        <div class="progress-fill" id="rankProgress" style="width: 60%"></div>
                    </div>
                    
                    <div id="rankAnalysis" style="color: #ccc; font-size: 14px; margin-top: 10px;">
                        根據您目前60%的勝率，在鑽石分組中表現良好，建議繼續保持。
                    </div>
                    
                    <div id="rankPrediction" style="color: #ffa726; font-size: 14px; margin-top: 10px;">
                        • 如果接下來5場全敗，勝率將降至46%，有掉級風險<br>
                        • 如果接下來5場全勝，勝率將升至71%，分組非常穩定
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 對戰矩陣面板 -->
        <div id="matrixPanel" class="panel">
            <div class="matrix-container">
                <h2 style="color: #ffd700; text-align: center; margin-bottom: 30px;">🎯 職業對戰勝率矩陣</h2>
                
                <!-- 矩陣切換按鈕 -->
                <div class="matrix-toggle">
                    <button class="matrix-btn active" onclick="showMatrixType('first')" id="firstMatrixBtn">🔴 先手勝率矩陣</button>
                    <button class="matrix-btn" onclick="showMatrixType('second')" id="secondMatrixBtn">🔵 後手勝率矩陣</button>
                </div>
                
                <!-- 先手勝率矩陣 -->
                <div id="firstMatrix" class="matrix-table-container active">
                    <h3 style="color: #FF6B6B; text-align: center; margin-bottom: 20px;">🔴 先手勝率矩陣</h3>
                    <div class="matrix-table" id="firstMatrixTable">
                        <!-- 先手矩陣表格將在此動態生成 -->
                    </div>
                    <div class="matrix-stats" id="firstMatrixStats">
                        <!-- 先手統計將在此顯示 -->
                    </div>
                </div>
                
                <!-- 後手勝率矩陣 -->
                <div id="secondMatrix" class="matrix-table-container">
                    <h3 style="color: #4ECDC4; text-align: center; margin-bottom: 20px;">🔵 後手勝率矩陣</h3>
                    <div class="matrix-table" id="secondMatrixTable">
                        <!-- 後手矩陣表格將在此動態生成 -->
                    </div>
                    <div class="matrix-stats" id="secondMatrixStats">
                        <!-- 後手統計將在此顯示 -->
                    </div>
                </div>
                
                <!-- 矩陣說明 -->
                <div class="matrix-info">
                    <h4 style="color: #ffd700; margin-bottom: 15px;">📋 使用說明</h4>
                    <ul style="color: #ccc; line-height: 1.6;">
                        <li><strong>縱軸（左側）</strong>：您使用的職業</li>
                        <li><strong>橫軸（上方）</strong>：對手使用的職業</li>
                        <li><strong>數值</strong>：該組合的勝率百分比</li>
                        <li><strong>顏色</strong>：
                            <span style="color: #4CAF50;">綠色</span> = 高勝率 (≥70%), 
                            <span style="color: #FFC107;">黃色</span> = 中等勝率 (50-69%), 
                            <span style="color: #F44336;">紅色</span> = 低勝率 (<50%)
                        </li>
                        <li><strong>--</strong>：表示該組合尚無對戰數據</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <!-- 玩家資料面板 -->
        <div id="playerPanel" class="panel">
            <div class="player-profile">
                <div class="profile-section">
                    <h3>👤 基本資料</h3>
                    <div class="profile-grid">
                        <div class="profile-item">
                            <div class="profile-label">玩家名稱</div>
                            <div class="profile-value editable" id="playerName" onclick="editPlayerName()">未設定</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">遊戲ID</div>
                            <div class="profile-value editable" id="gameId" onclick="editGameId()">未設定</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">註冊日期</div>
                            <div class="profile-value" id="registerDate">2025-06-29</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">主要職業</div>
                            <div class="profile-value editable" id="mainClass" onclick="editMainClass()">龍</div>
                        </div>
                    </div>
                </div>
                
                <div class="profile-section">
                    <h3>🎯 遊戲目標</h3>
                    <div class="profile-grid">
                        <div class="profile-item">
                            <div class="profile-label">目標分組</div>
                            <div class="profile-value editable" id="targetRank" onclick="editTargetRank()">鑽石</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">目標勝率</div>
                            <div class="profile-value" id="targetWinRate">70%</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">月目標場數</div>
                            <div class="profile-value" id="monthlyTarget">100場</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">目標BP</div>
                            <div class="profile-value" id="targetBP">60000</div>
                        </div>
                    </div>
                </div>
                
                <div class="profile-section">
                    <h3>📊 歷史紀錄</h3>
                    <div class="profile-grid">
                        <div class="profile-item">
                            <div class="profile-label">最高分組</div>
                            <div class="profile-value" id="highestRank">鑽石</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">最高BP</div>
                            <div class="profile-value" id="highestBP">52000</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">最長連勝</div>
                            <div class="profile-value" id="longestWinStreak">8場</div>
                        </div>
                        <div class="profile-item">
                            <div class="profile-label">總遊戲時間</div>
                            <div class="profile-value" id="totalPlayTime">45小時</div>
                        </div>
                    </div>
                </div>
                
                <!-- 保存操作區域 -->
                <div class="profile-section">
                    <h3>💾 資料管理</h3>
                    <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                        <button class="btn" onclick="savePlayerProfile()" style="background: #4caf50;">
                            💾 保存資料
                        </button>
                        <button class="btn" onclick="resetPlayerProfile()" style="background: #ff9800;">
                            🔄 重置資料
                        </button>
                        <button class="btn" onclick="exportPlayerProfile()" style="background: #2196f3;">
                            📤 匯出資料
                        </button>
                        <button class="btn" onclick="exportRankChangeAnalysis()" style="background: #9c27b0;">
                            📊 匯出分組變動分析
                        </button>
                    </div>
                    <div id="saveStatus" style="margin-top: 10px; color: #4caf50; font-size: 14px; display: none;">
                        ✅ 資料已保存
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 對戰記錄面板 -->
        <div id="battlePanel" class="panel">
            <div class="battle-form">
                <h3 style="color: #ffd700; margin-bottom: 20px;">⚔️ 新增對戰記錄</h3>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="myClass">我的職業</label>
                        <select id="myClass">
                            <option value="皇家">皇家</option>
                            <option value="精靈">精靈</option>
                            <option value="巫師">巫師</option>
                            <option value="龍" selected>龍</option>
                            <option value="夜魔">夜魔</option>
                            <option value="主教">主教</option>
                            <option value="復仇者">復仇者</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="opponentClass">對手職業</label>
                        <select id="opponentClass">
                            <option value="皇家">皇家</option>
                            <option value="精靈">精靈</option>
                            <option value="巫師">巫師</option>
                            <option value="龍">龍</option>
                            <option value="夜魔">夜魔</option>
                            <option value="主教">主教</option>
                            <option value="復仇者">復仇者</option>
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label for="turnOrder">先後手</label>
                        <select id="turnOrder">
                            <option value="">請選擇</option>
                            <option value="先手">先手</option>
                            <option value="後手">後手</option>
                        </select>
                    </div>
                </div>
                
                <div class="form-row">
                    <div class="form-group">
                        <label for="result">對戰結果</label>
                        <select id="result">
                            <option value="">請選擇</option>
                            <option value="勝">勝利</option>
                            <option value="敗">敗北</option>
                        </select>
                    </div>
                    
                    <div class="form-group" style="grid-column: span 2;">
                        <label for="bpChange">BP變化</label>
                        <input type="number" id="bpChange" placeholder="建議值: +320" min="0">
                    </div>
                </div>
                
                <button class="btn" onclick="addBattle()">新增對戰記錄</button>
            </div>
            
            <div class="battle-history">
                <h3 style="color: #ffd700; padding: 20px; margin: 0;">📋 對戰歷史</h3>
                <div id="battleList"></div>
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn export-btn" onclick="exportData()">📥 匯出數據</button>
                <button class="btn clear-btn" onclick="clearAllData()">🗑️ 清除數據</button>
            </div>
        </div>
        
        <!-- 設定匯入面板 -->
        <div id="settingsPanel" class="panel">
            <div class="import-area" id="importArea" onclick="document.getElementById('fileInput').click();">
                <p>📁 點擊此處選擇檔案或拖放文字檔案進行匯入</p>
                <p style="color: #ccc; font-size: 14px;">支援格式：.txt 文字檔案</p>
                <input type="file" id="fileInput" class="file-input" accept=".txt" onchange="importFromFile(event)">
            </div>
        </div>
    </div>

    <script>

        // === src/js/config.js ===
        // Shadowverse: Worlds Beyond Tracker - 配置與常數
// 此文件包含所有應用程式的配置常數和基礎數據

const CONFIG = {
    // localStorage keys
    STORAGE_KEYS: {
        PLAYER: 'shadowverseWorldsBeyondPlayer',
        BATTLES: 'shadowverseWorldsBeyondBattles',
        STARTING_BP: 'shadowverseWorldsBeyondStartingBP',
        CURRENT_RANK: 'shadowverseWorldsBeyondCurrentRank',
        RANK_CHANGES: 'shadowverseWorldsBeyondRankChanges'
    },
    
    // 默認值
    DEFAULTS: {
        STARTING_BP: 43945,
        CURRENT_RANK: '鑽石',
        WIN_BP: 320,
        LOSE_BP: 30
    },
    
    // 遊戲規則
    GAME_RULES: {
        MIN_GAMES_FOR_RANK_ADJUSTMENT: 15,
        MIN_GAMES_FOR_RANK_DANGER: 20
    }
};

// 階級數據
const RANK_DATA = {
    '綠寶石': {
        icon: '🟢',
        name: '綠寶石',
        maintain: 40,
        danger: 30,
        multiplier: 'x1.0',
        color: '#4caf50',
        description: '• 新手分組<br>• 升級條件：達到一定BP自動升級<br>• 勝率無壓力，倍率x1.0'
    },
    '黃寶石': {
        icon: '🟠',
        name: '黃寶石',
        maintain: 45,
        danger: 35,
        multiplier: 'x1.1',
        color: '#ffb300',
        description: '• 進階分組<br>• 升級條件：BP達標自動升級<br>• 勝率建議45%以上，倍率x1.1'
    },
    '紅寶石': {
        icon: '🔴',
        name: '紅寶石',
        maintain: 50,
        danger: 40,
        multiplier: 'x1.3',
        color: '#e53935',
        description: '• 中高級分組<br>• 升級條件：BP達標自動升級<br>• 勝率建議50%以上，倍率x1.3'
    },
    '藍寶石': {
        icon: '🔵',
        name: '藍寶石',
        maintain: 55,
        danger: 45,
        multiplier: 'x1.5',
        color: '#1e88e5',
        description: '• 高級分組<br>• 升級條件：BP達標自動升級<br>• 勝率建議55%以上，倍率x1.5'
    },
    '鑽石': {
        icon: '💎',
        name: '鑽石',
        maintain: 60,
        danger: 50,
        multiplier: 'x2.0',
        color: '#b39ddb',
        description: '• 最高分組<br>• 維持條件：勝率60%以上<br>• 低於50%有掉級風險，倍率x2.0'
    }
};

// 職業數據
const CLASS_DATA = {
    '皇家': { color: '#FFD700', textColor: '#000' },
    '精靈': { color: '#228B22', textColor: '#fff' },
    '巫師': { color: '#4169E1', textColor: '#fff' },
    '龍': { color: '#DC143C', textColor: '#fff' },
    '夜魔': { color: 'linear-gradient(45deg, #8B008B, #8B0000)', textColor: '#fff' },
    '主教': { color: '#F0E68C', textColor: '#000' },
    '復仇者': { color: '#2F4F4F', textColor: '#fff' }
};

// 職業列表（用於對戰矩陣）
const CLASS_LIST = ['皇家', '精靈', '巫師', '龍', '夜魔', '主教', '復仇者'];

// 默認玩家數據
const DEFAULT_PLAYER_DATA = {
    name: '未設定',
    gameId: '未設定',
    registerDate: '2025-06-29',
    mainClass: '龍',
    targetRank: '鑽石',
    targetWinRate: '70%',
    monthlyTarget: '100場',
    targetBP: '60000',
    highestRank: '鑽石',
    highestBP: '52000',
    longestWinStreak: '8場',
    totalPlayTime: '45小時'
};

// 默認對戰數據
const DEFAULT_BATTLE_DATA = [
    {id: 1, myClass: '龍', opponentClass: '皇家', result: '勝', bpChange: 320, timestamp: '2025-06-26', turnOrder: '先手'},
    {id: 2, myClass: '龍', opponentClass: '皇家', result: '勝', bpChange: 320, timestamp: '2025-06-26', turnOrder: '後手'},
    {id: 3, myClass: '龍', opponentClass: '精靈', result: '勝', bpChange: 380, timestamp: '2025-06-26', turnOrder: '先手'},
    {id: 4, myClass: '龍', opponentClass: '皇家', result: '勝', bpChange: 380, timestamp: '2025-06-26', turnOrder: '後手'},
    {id: 5, myClass: '龍', opponentClass: '精靈', result: '敗', bpChange: 30, timestamp: '2025-06-26', turnOrder: '先手'},
    {id: 6, myClass: '龍', opponentClass: '巫師', result: '敗', bpChange: 22, timestamp: '2025-06-26', turnOrder: '後手'},
    {id: 7, myClass: '龍', opponentClass: '復仇者', result: '敗', bpChange: 30, timestamp: '2025-06-26', turnOrder: '先手'},
    {id: 8, myClass: '龍', opponentClass: '巫師', result: '勝', bpChange: 260, timestamp: '2025-06-28', turnOrder: '後手'},
    {id: 9, myClass: '龍', opponentClass: '巫師', result: '勝', bpChange: 320, timestamp: '2025-06-28', turnOrder: '先手'},
    {id: 10, myClass: '龍', opponentClass: '巫師', result: '敗', bpChange: 28, timestamp: '2025-06-28', turnOrder: '後手'},
    {id: 11, myClass: '龍', opponentClass: '龍', result: '勝', bpChange: 320, timestamp: '2025-06-28', turnOrder: '先手'},
    {id: 12, myClass: '龍', opponentClass: '巫師', result: '敗', bpChange: 24, timestamp: '2025-06-28', turnOrder: '後手'},
    {id: 13, myClass: '皇家', opponentClass: '精靈', result: '勝', bpChange: 320, timestamp: '2025-06-29', turnOrder: '先手'},
    {id: 14, myClass: '皇家', opponentClass: '夜魔', result: '敗', bpChange: 30, timestamp: '2025-06-29', turnOrder: '後手'},
    {id: 15, myClass: '精靈', opponentClass: '主教', result: '勝', bpChange: 320, timestamp: '2025-06-29', turnOrder: '先手'},
    {id: 16, myClass: '精靈', opponentClass: '復仇者', result: '勝', bpChange: 380, timestamp: '2025-06-29', turnOrder: '後手'},
    {id: 17, myClass: '巫師', opponentClass: '皇家', result: '敗', bpChange: 25, timestamp: '2025-06-29', turnOrder: '先手'},
    {id: 18, myClass: '夜魔', opponentClass: '龍', result: '勝', bpChange: 340, timestamp: '2025-06-29', turnOrder: '後手'}
];

// 導出配置（ES6模組語法備用）
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        CONFIG,
        RANK_DATA,
        CLASS_DATA,
        DEFAULT_PLAYER_DATA,
        DEFAULT_BATTLE_DATA
    };
}


        // === src/js/data-manager.js ===
        // Shadowverse: Worlds Beyond Tracker - 數據管理模組
// 負責所有localStorage操作和數據管理

class DataManager {
    constructor() {
        this.playerData = this.loadPlayerData();
        this.battleData = this.loadBattleData();
        this.startingBP = this.loadStartingBP();
        this.currentRank = this.loadCurrentRank();
        this.rankChangeHistory = this.loadRankChangeHistory(); // 新增分組變動歷史
    }

    // 載入玩家資料
    loadPlayerData() {
        const stored = localStorage.getItem(CONFIG.STORAGE_KEYS.PLAYER);
        return stored ? JSON.parse(stored) : { ...DEFAULT_PLAYER_DATA };
    }

    // 儲存玩家資料
    savePlayerData(data = null) {
        if (data) this.playerData = data;
        localStorage.setItem(CONFIG.STORAGE_KEYS.PLAYER, JSON.stringify(this.playerData));
    }

    // 載入對戰數據
    loadBattleData() {
        const stored = localStorage.getItem(CONFIG.STORAGE_KEYS.BATTLES);
        return stored ? JSON.parse(stored) : [...DEFAULT_BATTLE_DATA];
    }

    // 儲存對戰數據
    saveBattleData(data = null) {
        if (data) this.battleData = data;
        localStorage.setItem(CONFIG.STORAGE_KEYS.BATTLES, JSON.stringify(this.battleData));
    }

    // 載入起始BP
    loadStartingBP() {
        const stored = localStorage.getItem(CONFIG.STORAGE_KEYS.STARTING_BP);
        return stored ? parseInt(stored) : CONFIG.DEFAULTS.STARTING_BP;
    }

    // 儲存起始BP
    saveStartingBP(bp = null) {
        if (bp !== null) this.startingBP = bp;
        localStorage.setItem(CONFIG.STORAGE_KEYS.STARTING_BP, this.startingBP);
    }

    // 載入當前階級
    loadCurrentRank() {
        const stored = localStorage.getItem(CONFIG.STORAGE_KEYS.CURRENT_RANK);
        return stored || CONFIG.DEFAULTS.CURRENT_RANK;
    }

    // 儲存當前階級
    saveCurrentRank(rank = null) {
        if (rank) this.currentRank = rank;
        localStorage.setItem(CONFIG.STORAGE_KEYS.CURRENT_RANK, this.currentRank);
    }

    // 載入分組變動歷史
    loadRankChangeHistory() {
        const stored = localStorage.getItem(CONFIG.STORAGE_KEYS.RANK_CHANGES);
        return stored ? JSON.parse(stored) : [];
    }

    // 儲存分組變動歷史
    saveRankChangeHistory(data = null) {
        if (data) this.rankChangeHistory = data;
        localStorage.setItem(CONFIG.STORAGE_KEYS.RANK_CHANGES, JSON.stringify(this.rankChangeHistory));
    }

    // 新增對戰記錄
    addBattle(battleData) {
        const newBattle = {
            id: this.battleData.length + 1,
            ...battleData,
            timestamp: new Date().toISOString().split('T')[0]
        };
        this.battleData.push(newBattle);
        this.saveBattleData();
        return newBattle;
    }

    // 編輯對戰記錄
    editBattle(battleId, updatedData) {
        const battleIndex = this.battleData.findIndex(battle => battle.id === battleId);
        if (battleIndex === -1) return false;

        // 保留原有的id和timestamp
        const originalBattle = this.battleData[battleIndex];
        this.battleData[battleIndex] = {
            ...originalBattle,
            ...updatedData,
            id: originalBattle.id,
            timestamp: originalBattle.timestamp
        };

        this.saveBattleData();
        return true;
    }

    // 刪除對戰記錄
    deleteBattle(battleId) {
        const battleIndex = this.battleData.findIndex(battle => battle.id === battleId);
        if (battleIndex === -1) return false;

        this.battleData.splice(battleIndex, 1);
        
        // 重新編號ID
        this.battleData.forEach((battle, index) => {
            battle.id = index + 1;
        });

        this.saveBattleData();
        
        // 同時清理相關的分組變動記錄
        this.rankChangeHistory = this.rankChangeHistory.filter(change => change.battleId !== battleId);
        this.saveRankChangeHistory();
        
        return true;
    }

    // 取得單一對戰記錄
    getBattle(battleId) {
        return this.battleData.find(battle => battle.id === battleId);
    }

    // 清除所有對戰數據
    clearAllBattles() {
        this.battleData = [];
        localStorage.removeItem(CONFIG.STORAGE_KEYS.BATTLES);
    }

    // 記錄分組變動
    recordRankChange(battleIndex, fromRank, toRank, winRate, totalGames, reason = '手動標記') {
        const battle = this.battleData[battleIndex];
        if (!battle) return false;

        const changeRecord = {
            id: this.rankChangeHistory.length + 1,
            battleId: battle.id,
            battleIndex: battleIndex + 1, // 顯示用（從1開始）
            timestamp: new Date().toISOString(),
            fromRank,
            toRank,
            battleDetails: {
                myClass: battle.myClass,
                opponentClass: battle.opponentClass,
                result: battle.result,
                turnOrder: battle.turnOrder,
                bpChange: battle.bpChange
            },
            statsAtChange: {
                winRate,
                totalGames,
                currentBP: this.startingBP + this.battleData.slice(0, battleIndex + 1).reduce((sum, b) => sum + b.bpChange, 0)
            },
            reason
        };

        this.rankChangeHistory.push(changeRecord);
        this.saveRankChangeHistory();
        return changeRecord;
    }

    // 刪除分組變動記錄
    removeRankChange(changeId) {
        this.rankChangeHistory = this.rankChangeHistory.filter(change => change.id !== changeId);
        this.saveRankChangeHistory();
    }

    // 計算統計數據
    getStatistics() {
        const totalGames = this.battleData.length;
        const wins = this.battleData.filter(b => b.result === '勝').length;
        const winRate = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;
        const currentBP = this.startingBP + this.battleData.reduce((sum, b) => sum + b.bpChange, 0);

        // 計算先手後手統計
        const firstTurnGames = this.battleData.filter(b => b.turnOrder === '先手');
        const secondTurnGames = this.battleData.filter(b => b.turnOrder === '後手');
        
        const firstTurnWins = firstTurnGames.filter(b => b.result === '勝').length;
        const secondTurnWins = secondTurnGames.filter(b => b.result === '勝').length;
        
        const firstWinRate = firstTurnGames.length > 0 ? Math.round((firstTurnWins / firstTurnGames.length) * 100) : 0;
        const secondWinRate = secondTurnGames.length > 0 ? Math.round((secondTurnWins / secondTurnGames.length) * 100) : 0;

        // 計算連勝/連敗
        let streak = 0;
        let streakType = '';
        if (totalGames > 0) {
            streakType = this.battleData[totalGames - 1].result;
            for (let i = totalGames - 1; i >= 0; i--) {
                if (this.battleData[i].result === streakType) {
                    streak++;
                } else {
                    break;
                }
            }
        }

        return {
            totalGames,
            wins,
            winRate,
            currentBP,
            streak,
            streakType,
            firstTurnGames: firstTurnGames.length,
            secondTurnGames: secondTurnGames.length,
            firstTurnWins,
            secondTurnWins,
            firstWinRate,
            secondWinRate,
            lastMatchResult: totalGames > 0 ? this.battleData[totalGames - 1].result : null
        };
    }

    // 取得職業對戰矩陣統計
    getMatrixStatistics() {
        const matrix = {
            first: {}, // 先手數據
            second: {} // 後手數據
        };

        // 初始化矩陣
        CLASS_LIST.forEach(myClass => {
            matrix.first[myClass] = {};
            matrix.second[myClass] = {};
            CLASS_LIST.forEach(opponentClass => {
                matrix.first[myClass][opponentClass] = { wins: 0, total: 0, winRate: 0 };
                matrix.second[myClass][opponentClass] = { wins: 0, total: 0, winRate: 0 };
            });
        });

        // 統計對戰數據
        this.battleData.forEach(battle => {
            const { myClass, opponentClass, result, turnOrder } = battle;
            
            // 只處理有先手/後手信息的對戰
            if (!turnOrder || !CLASS_LIST.includes(myClass) || !CLASS_LIST.includes(opponentClass)) {
                return;
            }

            const turnMatrix = turnOrder === '先手' ? matrix.first : matrix.second;
            
            if (turnMatrix[myClass] && turnMatrix[myClass][opponentClass]) {
                turnMatrix[myClass][opponentClass].total++;
                if (result === '勝') {
                    turnMatrix[myClass][opponentClass].wins++;
                }
                
                // 計算勝率
                const total = turnMatrix[myClass][opponentClass].total;
                const wins = turnMatrix[myClass][opponentClass].wins;
                turnMatrix[myClass][opponentClass].winRate = total > 0 ? Math.round((wins / total) * 100) : 0;
            }
        });

        return matrix;
    }

    // 導出數據
    exportData() {
        const stats = this.getStatistics();
        const currentRankLevel = RankManager.calculateRank(stats.currentBP);
        
        let exportText = `闇影詩章:凌越世界 對戰紀錄\n`;
        exportText += `日期：${new Date().toISOString().split('T')[0]}\n`;
        exportText += `階級：${currentRankLevel}\n`;
        exportText += `起始BP：${this.startingBP}\n`;
        exportText += `目前BP：${stats.currentBP}\n`;
        exportText += `分組：${RANK_DATA[this.currentRank].name}\n`;
        exportText += `總勝率：${stats.winRate}% (${stats.wins}勝/${stats.totalGames - stats.wins}敗)\n`;
        exportText += `先手勝率：${stats.firstWinRate}% (${stats.firstTurnWins}勝/${stats.firstTurnGames - stats.firstTurnWins}敗，共${stats.firstTurnGames}場)\n`;
        exportText += `後手勝率：${stats.secondWinRate}% (${stats.secondTurnWins}勝/${stats.secondTurnGames - stats.secondTurnWins}敗，共${stats.secondTurnGames}場)\n\n`;
        
        this.battleData.forEach((battle, index) => {
            const turnInfo = battle.turnOrder ? ` ${battle.turnOrder}` : '';
            exportText += `第${index + 1}場：${battle.myClass}對戰${battle.opponentClass}${turnInfo} ${battle.result}（${battle.bpChange > 0 ? '+' : ''}${battle.bpChange}BP）\n`;
        });
        
        return exportText;
    }

    // 解析導入數據
    parseImportData(content) {
        try {
            const lines = content.split('\n').map(line => line.trim()).filter(line => line);
            let newStartingBP = this.startingBP;
            let newCurrentBP = null;
            let detectedGroup = null; // 分組，不是階級
            const newBattleData = [];
            
            for (const line of lines) {
                // 解析起始BP
                if (line.includes('起始BP：')) {
                    const bpMatch = line.match(/起始BP：(\d+)/);
                    if (bpMatch) {
                        newStartingBP = parseInt(bpMatch[1]);
                    }
                }
                
                // 解析目前BP
                if (line.includes('目前BP：')) {
                    const bpMatch = line.match(/目前BP：(\d+)/);
                    if (bpMatch) {
                        newCurrentBP = parseInt(bpMatch[1]);
                    }
                }
                
                // 解析分組（不是階級）
                if (line.includes('分組：')) {
                    const groupMatch = line.match(/分組：(.+)/);
                    if (groupMatch) {
                        detectedGroup = groupMatch[1].trim();
                    }
                }
                
                // 解析對戰記錄（包含先手/後手信息）
                const battleMatchWithTurn = line.match(/第(\d+)場：(.+)對戰(.+)\s+(先手|後手)\s+(勝|敗)（\+(\d+)BP）/);
                const battleMatchSimple = line.match(/第(\d+)場：(.+)對戰(.+)\s+(勝|敗)（\+(\d+)BP）/);
                
                if (battleMatchWithTurn) {
                    const [, id, myClass, opponentClass, turnOrder, result, bpChange] = battleMatchWithTurn;
                    newBattleData.push({
                        id: parseInt(id),
                        myClass: this.convertOldClassName(myClass),
                        opponentClass: this.convertOldClassName(opponentClass),
                        result,
                        bpChange: parseInt(bpChange),
                        turnOrder,
                        timestamp: new Date().toISOString().split('T')[0]
                    });
                } else if (battleMatchSimple) {
                    const [, id, myClass, opponentClass, result, bpChange] = battleMatchSimple;
                    newBattleData.push({
                        id: parseInt(id),
                        myClass: this.convertOldClassName(myClass),
                        opponentClass: this.convertOldClassName(opponentClass),
                        result,
                        bpChange: parseInt(bpChange),
                        timestamp: new Date().toISOString().split('T')[0]
                    });
                }
            }
            
            if (newBattleData.length > 0) {
                // 計算預期的目前BP以驗證數據
                let calculatedBP = newStartingBP;
                newBattleData.forEach(battle => {
                    calculatedBP += battle.bpChange;
                });
                
                // 計算導入後的勝率以驗證分組
                const totalWins = newBattleData.filter(b => b.result === '勝').length;
                const totalGames = newBattleData.length;
                const winRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
                
                const importMessage = `找到 ${newBattleData.length} 筆對戰記錄\n` +
                    `起始BP：${newStartingBP}\n` +
                    `預期目前BP：${calculatedBP}${newCurrentBP ? `\n實際目前BP：${newCurrentBP}` : ''}\n` +
                    `預期勝率：${winRate}% (${totalWins}勝/${totalGames - totalWins}敗)\n` +
                    `${detectedGroup ? `檢測到分組：${detectedGroup}` : ''}\n\n` +
                    `是否要匯入？這會覆蓋現有數據。`;
                
                if (confirm(importMessage)) {
                    this.startingBP = newStartingBP;
                    this.battleData = newBattleData;
                    
                    // 如果檢測到分組，自動調整
                    if (detectedGroup && RANK_DATA[detectedGroup]) {
                        this.currentRank = detectedGroup;
                        this.saveCurrentRank();
                    }
                    
                    this.saveStartingBP();
                    this.saveBattleData();
                    return true;
                }
            }
            return false;
        } catch (error) {
            console.error('解析導入數據時發生錯誤:', error);
            throw new Error('數據格式不正確，無法解析');
        }
    }

    // 轉換舊職業名稱
    convertOldClassName(className) {
        const classMap = {
            '王室': '皇家',
            '妖精': '精靈',
            '法師': '巫師',
            '龍族': '龍',
            '死靈': '夜魔',
            '牧師': '主教',
            '復仇': '復仇者'
        };
        return classMap[className] || className;
    }

    // 取得分組變動統計
    getRankChangeAnalysis() {
        const analysis = {
            totalChanges: this.rankChangeHistory.length,
            upgradeCount: 0,
            downgradeCount: 0,
            changesByRank: {},
            averageGamesForChange: 0,
            winRateAtChanges: []
        };

        const rankOrder = ['綠寶石', '黃寶石', '紅寶石', '藍寶石', '鑽石'];
        
        this.rankChangeHistory.forEach(change => {
            const fromIndex = rankOrder.indexOf(change.fromRank);
            const toIndex = rankOrder.indexOf(change.toRank);
            
            if (toIndex > fromIndex) {
                analysis.upgradeCount++;
            } else if (toIndex < fromIndex) {
                analysis.downgradeCount++;
            }

            // 按分組統計
            if (!analysis.changesByRank[change.fromRank]) {
                analysis.changesByRank[change.fromRank] = { upgrades: 0, downgrades: 0, total: 0 };
            }
            
            if (toIndex > fromIndex) {
                analysis.changesByRank[change.fromRank].upgrades++;
            } else if (toIndex < fromIndex) {
                analysis.changesByRank[change.fromRank].downgrades++;
            }
            analysis.changesByRank[change.fromRank].total++;

            analysis.winRateAtChanges.push({
                winRate: change.statsAtChange.winRate,
                games: change.statsAtChange.totalGames,
                direction: toIndex > fromIndex ? 'upgrade' : 'downgrade'
            });
        });

        if (analysis.winRateAtChanges.length > 0) {
            analysis.averageGamesForChange = Math.round(
                analysis.winRateAtChanges.reduce((sum, item) => sum + item.games, 0) / analysis.winRateAtChanges.length
            );
        }

        return analysis;
    }

    // 匯出分組變動分析數據
    exportRankChangeAnalysis() {
        const analysis = this.getRankChangeAnalysis();
        const stats = this.getStatistics();
        
        let exportText = `闇影詩章:凌越世界 分組變動分析報告\n`;
        exportText += `生成日期：${new Date().toISOString().split('T')[0]}\n`;
        exportText += `目前狀態：${this.currentRank} | BP: ${stats.currentBP} | 勝率: ${stats.winRate}%\n\n`;
        
        exportText += `=== 分組變動統計 ===\n`;
        exportText += `總變動次數：${analysis.totalChanges}\n`;
        exportText += `升級次數：${analysis.upgradeCount}\n`;
        exportText += `降級次數：${analysis.downgradeCount}\n`;
        exportText += `平均變動場次：${analysis.averageGamesForChange}\n\n`;

        exportText += `=== 各分組變動詳情 ===\n`;
        Object.entries(analysis.changesByRank).forEach(([rank, data]) => {
            exportText += `${rank}：升級${data.upgrades}次，降級${data.downgrades}次，共${data.total}次\n`;
        });

        exportText += `\n=== 變動時勝率分析 ===\n`;
        const upgrades = analysis.winRateAtChanges.filter(item => item.direction === 'upgrade');
        const downgrades = analysis.winRateAtChanges.filter(item => item.direction === 'downgrade');
        
        if (upgrades.length > 0) {
            const avgUpgradeWinRate = Math.round(upgrades.reduce((sum, item) => sum + item.winRate, 0) / upgrades.length);
            exportText += `升級時平均勝率：${avgUpgradeWinRate}%\n`;
        }
        
        if (downgrades.length > 0) {
            const avgDowngradeWinRate = Math.round(downgrades.reduce((sum, item) => sum + item.winRate, 0) / downgrades.length);
            exportText += `降級時平均勝率：${avgDowngradeWinRate}%\n`;
        }

        exportText += `\n=== 詳細變動記錄 ===\n`;
        this.rankChangeHistory.forEach((change, index) => {
            exportText += `${index + 1}. 第${change.battleIndex}場後：${change.fromRank} → ${change.toRank}\n`;
            exportText += `   對戰：${change.battleDetails.myClass} vs ${change.battleDetails.opponentClass} `;
            exportText += `${change.battleDetails.turnOrder || ''} ${change.battleDetails.result} (${change.battleDetails.bpChange > 0 ? '+' : ''}${change.battleDetails.bpChange}BP)\n`;
            exportText += `   當時狀態：勝率${change.statsAtChange.winRate}% (${change.statsAtChange.totalGames}場) BP:${change.statsAtChange.currentBP}\n`;
            exportText += `   原因：${change.reason}\n`;
            exportText += `   時間：${change.timestamp.split('T')[0]}\n\n`;
        });

        return exportText;
    }
}

// 全域數據管理實例
const dataManager = new DataManager();


        // === src/js/rank-manager.js ===
        // Shadowverse: Worlds Beyond Tracker - 階級管理模組
// 負責階級計算、升降級邏輯和相關功能

class RankManager {
    // 計算BP對應的階級
    static calculateRank(bp) {
        if (bp >= 60000) return 'Master';
        if (bp >= 50000) return 'A3';
        if (bp >= 45000) return 'A2';
        if (bp >= 40000) return 'A1';
        if (bp >= 35000) return 'B3';
        if (bp >= 30000) return 'B2';
        if (bp >= 25000) return 'B1';
        if (bp >= 20000) return 'C3';
        if (bp >= 15000) return 'C2';
        if (bp >= 10000) return 'C1';
        if (bp >= 5000) return 'D3';
        if (bp >= 2000) return 'D2';
        if (bp >= 1000) return 'D1';
        return 'Beginner';
    }

    // 自動階級調整邏輯
    // 注意：此功能目前為實驗性質，分組升降規則尚未完善
    // 建議使用手動分組標記功能以獲得更準確的分組追蹤
    static autoAdjustRank(winRate, totalGames, currentRank, lastMatchResult = null) {
        // 需要至少15場對戰才開始分組調整
        if (totalGames < CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_ADJUSTMENT) {
            return currentRank;
        }
        
        // TODO: 需要更多實際遊戲數據來完善升降級規則
        // 目前的邏輯僅為基礎估算，可能與實際遊戲規則有差異
        
        const rankOrder = ['綠寶石', '黃寶石', '紅寶石', '藍寶石', '鑽石'];
        const currentIndex = rankOrder.indexOf(currentRank);
        const currentRankData = RANK_DATA[currentRank];
        
        // 嚴格掉級條件：勝率遠低於警戒線
        if (winRate < currentRankData.danger - 5 && totalGames >= CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER) {
            if (currentIndex > 0) {
                return rankOrder[currentIndex - 1];
            }
        }
        
        // 臨界掉級條件
        if (totalGames >= CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER && currentIndex > 0) {
            if (winRate < currentRankData.maintain) {
                const isDangerZone = winRate <= Math.max(currentRankData.danger + 5, 50);
                const isBlueRank50 = (currentRank === '藍寶石' && winRate === 50);
                
                if ((isDangerZone || isBlueRank50) && lastMatchResult === '敗') {
                    return rankOrder[currentIndex - 1];
                }
            }
        }
        
        // 升級條件
        if (winRate >= currentRankData.maintain + 10 && 
            currentIndex < rankOrder.length - 1 && 
            totalGames >= CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_ADJUSTMENT) {
            const nextRankData = RANK_DATA[rankOrder[currentIndex + 1]];
            if (winRate >= nextRankData.maintain) {
                return rankOrder[currentIndex + 1];
            }
        }
        
        return currentRank;
    }

    // 顯示階級變更通知
    static showRankChangeNotification(oldRank, newRank, winRate) {
        const oldRankData = RANK_DATA[oldRank];
        const newRankData = RANK_DATA[newRank];
        
        const rankOrder = ['綠寶石', '黃寶石', '紅寶石', '藍寶石', '鑽石'];
        const isUpgrade = rankOrder.indexOf(newRank) > rankOrder.indexOf(oldRank);
        
        const message = isUpgrade 
            ? `🎉 恭喜升級！\n${oldRankData.icon} ${oldRankData.name} → ${newRankData.icon} ${newRankData.name}\n\n目前勝率：${winRate}%\n請繼續保持優秀表現！`
            : `📉 分組調整通知\n${oldRankData.icon} ${oldRankData.name} → ${newRankData.icon} ${newRankData.name}\n\n目前勝率：${winRate}%\n建議提升勝率以重回更高分組！`;
        
        alert(message);
    }

    // 分析階級狀態
    static analyzeRankStatus(winRate, totalGames, currentRank) {
        const rank = RANK_DATA[currentRank];
        const maintainThreshold = rank.maintain;
        const dangerThreshold = rank.danger;
        
        // 如果場次太少，給予提示
        if (totalGames < CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_ADJUSTMENT) {
            return {
                status: '📊 數據收集中',
                statusClass: 'rank-safe',
                analysis: `目前有${totalGames}場對戰記錄，建議至少進行${CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_ADJUSTMENT}場對戰後系統才會進行分組調整評估。`
            };
        }

        let status, statusClass, analysis;

        if (winRate >= maintainThreshold + 10) {
            status = '✅ 分組非常穩定';
            statusClass = 'rank-safe';
            analysis = `您的${winRate}%勝率在${rank.name}分組中表現優異，完全不用擔心掉級問題。`;
            
            // 檢查是否可以升級
            const rankOrder = ['綠寶石', '黃寶石', '紅寶石', '藍寶石', '鑽石'];
            const currentIndex = rankOrder.indexOf(currentRank);
            if (currentIndex < rankOrder.length - 1) {
                const nextRank = rankOrder[currentIndex + 1];
                const nextRankData = RANK_DATA[nextRank];
                if (winRate >= nextRankData.maintain) {
                    analysis += ` 您的勝率已達到${nextRankData.name}分組標準，系統可能會自動升級。`;
                }
            }
        } else if (winRate >= maintainThreshold) {
            status = '✅ 分組安全';
            statusClass = 'rank-safe';
            analysis = `您的${winRate}%勝率在${rank.name}分組中表現良好，建議繼續保持。`;
        } else if (winRate >= maintainThreshold - 5) {
            status = '⚠️ 需要注意';
            statusClass = 'rank-warning';
            analysis = `您的${winRate}%勝率略低於${rank.name}分組建議標準(${maintainThreshold}%)，建議提升勝率。`;
        } else if (winRate >= dangerThreshold) {
            status = '🚨 掉級風險';
            statusClass = 'rank-danger';
            
            if (totalGames >= CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER) {
                const isDangerZone = winRate <= Math.max(dangerThreshold + 5, 50);
                const isBlueRank50 = (currentRank === '藍寶石' && winRate === 50);
                
                if (isDangerZone || isBlueRank50) {
                    analysis = `您的${winRate}%勝率已在臨界區域，下一場敗戰可能觸發掉級機制。`;
                } else {
                    analysis = `您的${winRate}%勝率接近掉級警戒線(${dangerThreshold}%)，建議盡快提升勝率。`;
                }
            } else {
                analysis = `您的${winRate}%勝率接近掉級警戒線，但還需要${CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER - totalGames}場對戰才會觸發分組調整。`;
            }
        } else {
            status = '💥 極度危險';
            statusClass = 'rank-danger';
            if (totalGames >= CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER) {
                analysis = `您的${winRate}%勝率極低，系統已自動調整分組。建議調整策略重回更高分組。`;
            } else {
                analysis = `您的${winRate}%勝率極低，還有${CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER - totalGames}場緩衝期。請立即調整策略提升勝率！`;
            }
        }

        return { status, statusClass, analysis };
    }

    // 生成勝率預測
    static generatePredictions(wins, totalGames, winRate, maintainThreshold, dangerThreshold, currentRank) {
        const lose5 = Math.round(((wins) / (totalGames + 5)) * 100);
        const win5 = Math.round(((wins + 5) / (totalGames + 5)) * 100);
        
        let prediction = '';
        
        // 特別提醒臨界掉級風險
        if (totalGames >= CONFIG.GAME_RULES.MIN_GAMES_FOR_RANK_DANGER && winRate < maintainThreshold) {
            const isDangerZone = winRate <= Math.max(dangerThreshold + 5, 50);
            const isBlueRank50 = (currentRank === '藍寶石' && winRate === 50);
            
            if (isDangerZone || isBlueRank50) {
                prediction += `• 🚨 <strong>掉級風險警告</strong>：您的勝率已在臨界區域，下一場敗戰可能觸發掉級！<br>`;
            }
        }
        
        if (lose5 < dangerThreshold - 5) {
            prediction += `• ⚠️ 如果接下來5場全敗，勝率將降至${lose5}%，有嚴重掉級風險<br>`;
        } else if (lose5 < dangerThreshold) {
            prediction += `• ⚠️ 如果接下來5場全敗，勝率將降至${lose5}%，有掉級風險<br>`;
        } else {
            prediction += `• 如果接下來5場全敗，勝率將降至${lose5}%<br>`;
        }
        
        prediction += `• 如果接下來5場全勝，勝率將升至${win5}%`;
        
        if (win5 >= maintainThreshold + 10) {
            prediction += '，分組將非常穩定';
        } else if (win5 >= maintainThreshold) {
            prediction += '，分組將很安全';
        }
        
        return prediction;
    }
}


        // === src/js/ui-controller.js ===
        // Shadowverse: Worlds Beyond Tracker - UI控制器
// 負責所有UI更新、事件處理和面板管理

class UIController {
    constructor() {
        this.init();
    }

    // 初始化UI
    init() {
        this.initPlayerData();
        this.updateStats();
        this.renderBattles();
        this.bindEvents();
    }

    // 面板切換功能
    showPanel(panelName) {
        // 隱藏所有面板
        document.querySelectorAll('.panel').forEach(panel => {
            panel.classList.remove('active');
        });
        
        // 移除所有導航按鈕的active class
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        // 顯示指定面板
        const targetPanel = document.getElementById(panelName + 'Panel');
        if (targetPanel) {
            targetPanel.classList.add('active');
        }
        
        // 設定對應導航按鈕為active
        // 找到對應的導航按鈕並設為active
        const navButtons = document.querySelectorAll('.nav-btn');
        navButtons.forEach(btn => {
            if (btn.onclick && btn.onclick.toString().includes(panelName)) {
                btn.classList.add('active');
            }
        });
        
        // 如果是矩陣面板，渲染矩陣數據
        if (panelName === 'matrix') {
            this.renderMatrix();
        }
    }

    // 初始化玩家資料顯示
    initPlayerData() {
        const elements = [
            'playerName', 'gameId', 'registerDate', 'mainClass', 
            'targetRank', 'targetWinRate', 'monthlyTarget', 'targetBP',
            'highestRank', 'highestBP', 'longestWinStreak', 'totalPlayTime'
        ];

        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element && dataManager.playerData[id]) {
                element.textContent = dataManager.playerData[id];
            }
        });
    }

    // 更新統計資訊
    updateStats() {
        const stats = dataManager.getStatistics();
        
        // 檢查階級自動調整
        const oldRank = dataManager.currentRank;
        const newRank = RankManager.autoAdjustRank(
            stats.winRate, 
            stats.totalGames, 
            dataManager.currentRank, 
            stats.lastMatchResult
        );

        if (newRank !== dataManager.currentRank) {
            console.log(`分組自動調整：${dataManager.currentRank} → ${newRank} (勝率: ${stats.winRate}%, 最後一場: ${stats.lastMatchResult})`);
            dataManager.currentRank = newRank;
            dataManager.saveCurrentRank();
            RankManager.showRankChangeNotification(oldRank, newRank, stats.winRate);
        }

        // 更新顯示元素
        const currentRankLevel = RankManager.calculateRank(stats.currentBP);
        const streakText = stats.streak + (stats.streakType === '勝' ? '連勝' : '連敗');

        this.updateElement('currentBP', stats.currentBP.toLocaleString());
        this.updateElement('startingBP', dataManager.startingBP.toLocaleString());
        this.updateElement('currentRank', `${RANK_DATA[dataManager.currentRank].icon} ${RANK_DATA[dataManager.currentRank].name}`);
        this.updateElement('currentRankLevel', currentRankLevel);
        this.updateElement('totalGames', stats.totalGames);
        this.updateElement('winRate', stats.winRate + '%');
        
        // 更新先手後手勝率
        this.updateElement('firstWinRate', stats.firstTurnGames > 0 ? `${stats.firstWinRate}%` : '--');
        this.updateElement('secondWinRate', stats.secondTurnGames > 0 ? `${stats.secondWinRate}%` : '--');
        
        this.updateElement('streak', streakText);

        this.updateRankCalculator(stats.totalGames, stats.wins, stats.winRate);
    }

    // 更新階級計算器
    updateRankCalculator(totalGames, wins, winRate) {
        const rankStatusText = document.getElementById('rankStatusText');
        const rankProgress = document.getElementById('rankProgress');
        const rankAnalysis = document.getElementById('rankAnalysis');
        const rankPrediction = document.getElementById('rankPrediction');
        
        if (!rankStatusText || !rankProgress || !rankAnalysis || !rankPrediction) return;

        const rank = RANK_DATA[dataManager.currentRank];
        const { status, statusClass, analysis } = RankManager.analyzeRankStatus(winRate, totalGames, dataManager.currentRank);
        
        // 設定進度條寬度
        rankProgress.style.width = winRate + '%';
        
        // 更新狀態顯示
        rankStatusText.textContent = status;
        rankStatusText.className = statusClass;
        rankAnalysis.textContent = analysis;
        
        // 更新預測
        const prediction = RankManager.generatePredictions(
            wins, totalGames, winRate, 
            rank.maintain, rank.danger, dataManager.currentRank
        );
        rankPrediction.innerHTML = prediction;
    }

    // 渲染對戰記錄
    renderBattles() {
        const battleList = document.getElementById('battleList');
        if (!battleList) return;

        battleList.innerHTML = '';
        
        dataManager.battleData.slice().reverse().forEach((battle, reverseIndex) => {
            const battleIndex = dataManager.battleData.length - 1 - reverseIndex; // 實際索引
            const battleItem = document.createElement('div');
            battleItem.className = 'battle-item';
            
            // 先手後手顯示
            const turnInfo = battle.turnOrder ? `<span class="turn-order ${battle.turnOrder}">${battle.turnOrder}</span>` : '';
            
            // 檢查是否已標記分組變動
            const isMarked = dataManager.rankChangeHistory.some(change => change.battleId === battle.id);
            const markButton = `<button class="rank-change-btn ${isMarked ? 'marked' : ''}" 
                onclick="toggleRankChange(${battleIndex}, ${battle.id})" 
                title="${isMarked ? '已標記分組變動' : '標記分組變動'}">
                ${isMarked ? '📍' : '📌'}
            </button>`;
            
            // 編輯和刪除按鈕
            const editButton = `<button class="edit-btn" onclick="editBattle(${battle.id})" title="編輯對戰記錄">✏️</button>`;
            const deleteButton = `<button class="delete-btn" onclick="deleteBattle(${battle.id})" title="刪除對戰記錄">🗑️</button>`;
            
            battleItem.innerHTML = `
                <div class="battle-info">
                    <span class="职业-icon ${battle.myClass}">${battle.myClass}</span> vs 
                    <span class="职业-icon ${battle.opponentClass}">${battle.opponentClass}</span>
                    ${turnInfo}
                    <span class="bp-change">${battle.bpChange > 0 ? '+' : ''}${battle.bpChange}BP</span>
                    <small style="color: #ccc;">${battle.timestamp}</small>
                    <div class="battle-actions">
                        ${markButton}
                        ${editButton}
                        ${deleteButton}
                    </div>
                </div>
                <div class="battle-result ${battle.result === '勝' ? 'win' : 'lose'}">
                    ${battle.result}
                </div>
            `;
            battleList.appendChild(battleItem);
        });
    }

    // 新增對戰記錄
    addBattle() {
        const myClass = document.getElementById('myClass')?.value;
        const opponentClass = document.getElementById('opponentClass')?.value;
        const turnOrder = document.getElementById('turnOrder')?.value;
        const result = document.getElementById('result')?.value;
        const bpChangeInput = document.getElementById('bpChange');
        const bpValue = bpChangeInput?.value.replace(/^\+/, ''); // 移除前導+號
        const bpChange = parseInt(bpValue) || 0;
        
        // 驗證必填欄位
        if (!turnOrder) {
            alert('請選擇先手或後手！');
            document.getElementById('turnOrder')?.focus();
            return;
        }
        
        if (!result) {
            alert('請選擇對戰結果！');
            document.getElementById('result')?.focus();
            return;
        }
        
        if (bpChange === 0) {
            alert('請輸入BP變化值！');
            bpChangeInput?.focus();
            bpChangeInput?.classList.add('error');
            return;
        }
        
        // 驗證BP值範圍
        if (Math.abs(bpChange) > 1000) {
            const confirmMsg = `BP變化值 ${bpChange} 似乎很大，是否確認無誤？`;
            if (!confirm(confirmMsg)) {
                bpChangeInput?.focus();
                bpChangeInput?.select();
                return;
            }
        }
        
        const newBattle = {
            myClass,
            opponentClass,
            turnOrder,
            result,
            bpChange
        };
        
        dataManager.addBattle(newBattle);
        
        // 成功提示
        bpChangeInput?.classList.remove('error', 'warning');
        bpChangeInput?.classList.add('success');
        setTimeout(() => {
            bpChangeInput?.classList.remove('success');
        }, 1000);
        
        // 清空表單
        if (bpChangeInput) bpChangeInput.value = '';
        document.getElementById('turnOrder').value = '';
        document.getElementById('result').value = '';
        
        this.updateStats();
        this.renderBattles();
        
        // 顯示成功訊息
        this.showToast('對戰記錄已新增！', 'success');
    }

    // 編輯起始BP
    editStartingBP() {
        const newStartingBP = prompt('請輸入新的起始BP：', dataManager.startingBP);
        
        if (newStartingBP !== null && !isNaN(newStartingBP) && newStartingBP !== '') {
            const parsedBP = parseInt(newStartingBP);
            if (parsedBP >= 0) {
                dataManager.startingBP = parsedBP;
                dataManager.saveStartingBP();
                this.updateStats();
                
                // 添加視覺反饋
                const startingBPElement = document.getElementById('startingBP');
                if (startingBPElement) {
                    startingBPElement.style.transform = 'scale(1.1)';
                    startingBPElement.style.color = '#4CAF50';
                    setTimeout(() => {
                        startingBPElement.style.transform = 'scale(1)';
                        startingBPElement.style.color = '#ffd700';
                    }, 500);
                }
            } else {
                alert('BP不能為負數！');
            }
        }
    }

    // 編輯當前階級
    editCurrentRank() {
        const newRank = prompt(
            `請選擇目前分組：\n\n可選分組：\n🟢 綠寶石\n🟠 黃寶石\n🔴 紅寶石\n🔵 藍寶石\n💎 鑽石\n\n請輸入分組名稱（例：鑽石）：`,
            RANK_DATA[dataManager.currentRank].name
        );
        
        if (newRank !== null) {
            const rankKey = Object.keys(RANK_DATA).find(key => RANK_DATA[key].name === newRank.trim());
            if (rankKey) {
                dataManager.currentRank = rankKey;
                dataManager.saveCurrentRank();
                this.updateStats();
                
                // 添加視覺反饋
                const currentRankElement = document.getElementById('currentRank');
                if (currentRankElement) {
                    currentRankElement.style.transform = 'scale(1.1)';
                    currentRankElement.style.color = '#4CAF50';
                    setTimeout(() => {
                        currentRankElement.style.transform = 'scale(1)';
                        currentRankElement.style.color = '#ffd700';
                    }, 500);
                }
            } else {
                alert('請輸入正確的分組名稱！');
            }
        }
    }

    // 玩家資料編輯函數
    editPlayerName() {
        this.editPlayerField('name', '請輸入玩家名稱：', 'playerName');
    }

    editGameId() {
        this.editPlayerField('gameId', '請輸入遊戲ID：', 'gameId');
    }

    editMainClass() {
        const classes = Object.keys(CLASS_DATA);
        const newClass = prompt('請選擇主要職業：\n' + classes.join(', '), dataManager.playerData.mainClass);
        if (newClass !== null && classes.includes(newClass.trim())) {
            this.editPlayerField('mainClass', null, 'mainClass', newClass.trim());
        }
    }

    editTargetRank() {
        const ranks = Object.keys(RANK_DATA);
        const newRank = prompt('請選擇目標分組：\n' + ranks.join(', '), dataManager.playerData.targetRank);
        if (newRank !== null && ranks.includes(newRank.trim())) {
            this.editPlayerField('targetRank', null, 'targetRank', newRank.trim());
        }
    }

    // 通用玩家資料編輯
    editPlayerField(field, promptText, elementId, value = null) {
        const newValue = value || (promptText ? prompt(promptText, dataManager.playerData[field]) : null);
        if (newValue !== null && newValue.trim() !== '') {
            dataManager.playerData[field] = newValue.trim();
            this.updateElement(elementId, dataManager.playerData[field]);
            dataManager.savePlayerData();
            this.showSaveStatus('✅ 資料已自動保存', '#4caf50');
        }
    }

    // 玩家資料管理功能
    savePlayerProfile() {
        try {
            dataManager.savePlayerData();
            this.showSaveStatus('✅ 玩家資料已保存', '#4caf50');
            console.log('玩家資料保存成功');
        } catch (error) {
            this.showSaveStatus('❌ 保存失敗', '#f44336');
            console.error('玩家資料保存失敗:', error);
        }
    }

    resetPlayerProfile() {
        if (confirm('確定要重置所有玩家資料嗎？此操作無法復原！')) {
            try {
                // 重置玩家資料為預設值
                dataManager.playerData = { ...DEFAULT_PLAYER_DATA };
                dataManager.savePlayerData();
                this.initPlayerData(); // 重新載入顯示
                this.showSaveStatus('✅ 玩家資料已重置', '#ff9800');
                console.log('玩家資料重置成功');
            } catch (error) {
                this.showSaveStatus('❌ 重置失敗', '#f44336');
                console.error('玩家資料重置失敗:', error);
            }
        }
    }

    exportPlayerProfile() {
        try {
            const playerDataText = JSON.stringify(dataManager.playerData, null, 2);
            const exportContent = `# Shadowverse: Worlds Beyond - 玩家資料\n\n${playerDataText}`;
            
            const blob = new Blob([exportContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shadowverse_player_profile_${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showSaveStatus('✅ 玩家資料已匯出', '#2196f3');
            console.log('玩家資料匯出成功');
        } catch (error) {
            this.showSaveStatus('❌ 匯出失敗', '#f44336');
            console.error('玩家資料匯出失敗:', error);
        }
    }

    // 編輯對戰記錄
    editBattle(battleId) {
        const battle = dataManager.getBattle(battleId);
        if (!battle) {
            this.showToast('找不到對戰記錄', 'error');
            return;
        }

        // 創建編輯對話框
        const dialogHtml = `
            <div style="background: #2a2a3e; padding: 20px; border-radius: 10px; color: white; max-width: 500px;">
                <h3 style="color: #ffd700; margin-top: 0;">編輯對戰記錄 #${battle.id}</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;">我的職業：</label>
                        <select id="editMyClass" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="皇家" ${battle.myClass === '皇家' ? 'selected' : ''}>皇家</option>
                            <option value="精靈" ${battle.myClass === '精靈' ? 'selected' : ''}>精靈</option>
                            <option value="巫師" ${battle.myClass === '巫師' ? 'selected' : ''}>巫師</option>
                            <option value="龍" ${battle.myClass === '龍' ? 'selected' : ''}>龍</option>
                            <option value="夜魔" ${battle.myClass === '夜魔' ? 'selected' : ''}>夜魔</option>
                            <option value="主教" ${battle.myClass === '主教' ? 'selected' : ''}>主教</option>
                            <option value="復仇者" ${battle.myClass === '復仇者' ? 'selected' : ''}>復仇者</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px;">對手職業：</label>
                        <select id="editOpponentClass" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="皇家" ${battle.opponentClass === '皇家' ? 'selected' : ''}>皇家</option>
                            <option value="精靈" ${battle.opponentClass === '精靈' ? 'selected' : ''}>精靈</option>
                            <option value="巫師" ${battle.opponentClass === '巫師' ? 'selected' : ''}>巫師</option>
                            <option value="龍" ${battle.opponentClass === '龍' ? 'selected' : ''}>龍</option>
                            <option value="夜魔" ${battle.opponentClass === '夜魔' ? 'selected' : ''}>夜魔</option>
                            <option value="主教" ${battle.opponentClass === '主教' ? 'selected' : ''}>主教</option>
                            <option value="復仇者" ${battle.opponentClass === '復仇者' ? 'selected' : ''}>復仇者</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px;">先手/後手：</label>
                        <select id="editTurnOrder" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="" ${!battle.turnOrder ? 'selected' : ''}>未記錄</option>
                            <option value="先手" ${battle.turnOrder === '先手' ? 'selected' : ''}>先手</option>
                            <option value="後手" ${battle.turnOrder === '後手' ? 'selected' : ''}>後手</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px;">對戰結果：</label>
                        <select id="editResult" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="勝" ${battle.result === '勝' ? 'selected' : ''}>勝</option>
                            <option value="敗" ${battle.result === '敗' ? 'selected' : ''}>敗</option>
                        </select>
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">BP變化：</label>
                    <input type="number" id="editBpChange" value="${battle.bpChange}" 
                           style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;" />
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                            style="padding: 8px 16px; margin-right: 10px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
                    <button onclick="saveEditBattle(${battleId})" 
                            style="padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">保存</button>
                </div>
            </div>
        `;
        
        this.showModal(dialogHtml);
    }

    // 刪除對戰記錄
    deleteBattle(battleId) {
        const battle = dataManager.getBattle(battleId);
        if (!battle) {
            this.showToast('找不到對戰記錄', 'error');
            return;
        }

        const confirmMessage = `確定要刪除以下對戰記錄嗎？\n\n` +
            `第${battle.id}場：${battle.myClass} vs ${battle.opponentClass} ` +
            `${battle.turnOrder || ''} ${battle.result} (${battle.bpChange > 0 ? '+' : ''}${battle.bpChange}BP)\n\n` +
            `注意：刪除後無法復原，相關的分組變動標記也會一併清除。`;

        if (confirm(confirmMessage)) {
            if (dataManager.deleteBattle(battleId)) {
                this.showToast('對戰記錄已刪除', 'success');
                this.updateStats();
                this.renderBattles();
                this.renderMatrix(); // 更新矩陣
            } else {
                this.showToast('刪除失敗', 'error');
            }
        }
    }

    // 保存編輯的對戰記錄
    saveEditBattle(battleId) {
        console.log('saveEditBattle called with battleId:', battleId);
        
        const myClassEl = document.getElementById('editMyClass');
        const opponentClassEl = document.getElementById('editOpponentClass');
        const turnOrderEl = document.getElementById('editTurnOrder');
        const resultEl = document.getElementById('editResult');
        const bpChangeEl = document.getElementById('editBpChange');
        
        console.log('Elements found:', {
            myClass: myClassEl?.value,
            opponentClass: opponentClassEl?.value,
            turnOrder: turnOrderEl?.value,
            result: resultEl?.value,
            bpChange: bpChangeEl?.value
        });
        
        if (!myClassEl || !opponentClassEl || !resultEl || !bpChangeEl) {
            console.error('某些表單元素未找到');
            alert('表單元素未找到，請重試');
            return;
        }
        
        const updatedData = {
            myClass: myClassEl.value,
            opponentClass: opponentClassEl.value,
            turnOrder: turnOrderEl?.value || null,
            result: resultEl.value,
            bpChange: parseInt(bpChangeEl.value)
        };

        console.log('Updated data:', updatedData);

        // 驗證BP變化
        if (isNaN(updatedData.bpChange)) {
            alert('請輸入有效的BP變化數值');
            return;
        }

        console.log('Calling dataManager.editBattle...');
        try {
            const success = dataManager.editBattle(battleId, updatedData);
            console.log('Edit result:', success);
            
            if (success) {
                this.showToast('對戰記錄已更新', 'success');
                this.updateStats();
                this.renderBattles();
                if (typeof this.renderMatrix === 'function') {
                    this.renderMatrix(); // 更新矩陣
                }
                
                // 更安全的關閉對話框方式
                const modal = document.querySelector('.edit-modal');
                if (modal) {
                    modal.remove();
                    console.log('Modal closed via .edit-modal class');
                } else {
                    // 備用方法：尋找包含編輯表單的對話框
                    const dialog = document.querySelector('[style*="position: fixed"]');
                    if (dialog) {
                        dialog.remove();
                        console.log('Modal closed via fixed position selector');
                    } else {
                        console.log('No modal found to close');
                    }
                }
            } else {
                this.showToast('更新失敗', 'error');
                console.error('dataManager.editBattle returned false');
            }
        } catch (error) {
            console.error('Error in editBattle:', error);
            this.showToast('更新時發生錯誤: ' + error.message, 'error');
        }
    }

    // 顯示模態對話框
    showModal(content) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.7); display: flex; align-items: center; 
            justify-content: center; z-index: 10000;
        `;
        modal.innerHTML = content;
        document.body.appendChild(modal);
        
        // 點擊背景關閉
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    // 更新統計資訊（擴展原有方法）
    updateStats() {
        const stats = dataManager.getStatistics();
        
        // 檢查階級自動調整
        const oldRank = dataManager.currentRank;
        const newRank = RankManager.autoAdjustRank(
            stats.winRate, 
            stats.totalGames, 
            dataManager.currentRank, 
            stats.lastMatchResult
        );

        if (newRank !== dataManager.currentRank) {
            console.log(`分組自動調整：${dataManager.currentRank} → ${newRank} (勝率: ${stats.winRate}%, 最後一場: ${stats.lastMatchResult})`);
            dataManager.currentRank = newRank;
            dataManager.saveCurrentRank();
            RankManager.showRankChangeNotification(oldRank, newRank, stats.winRate);
        }

        // 更新顯示元素
        const currentRankLevel = RankManager.calculateRank(stats.currentBP);
        const streakText = stats.streak + (stats.streakType === '勝' ? '連勝' : '連敗');

        this.updateElement('currentBP', stats.currentBP.toLocaleString());
        this.updateElement('startingBP', dataManager.startingBP.toLocaleString());
        this.updateElement('currentRank', `${RANK_DATA[dataManager.currentRank].icon} ${RANK_DATA[dataManager.currentRank].name}`);
        this.updateElement('currentRankLevel', currentRankLevel);
        this.updateElement('totalGames', stats.totalGames);
        this.updateElement('winRate', stats.winRate + '%');
        
        // 更新先手後手勝率
        this.updateElement('firstWinRate', stats.firstTurnGames > 0 ? `${stats.firstWinRate}%` : '--');
        this.updateElement('secondWinRate', stats.secondTurnGames > 0 ? `${stats.secondWinRate}%` : '--');
        
        this.updateElement('streak', streakText);

        this.updateRankCalculator(stats.totalGames, stats.wins, stats.winRate);
    }

    // 更新階級計算器
    updateRankCalculator(totalGames, wins, winRate) {
        const rankStatusText = document.getElementById('rankStatusText');
        const rankProgress = document.getElementById('rankProgress');
        const rankAnalysis = document.getElementById('rankAnalysis');
        const rankPrediction = document.getElementById('rankPrediction');
        
        if (!rankStatusText || !rankProgress || !rankAnalysis || !rankPrediction) return;

        const rank = RANK_DATA[dataManager.currentRank];
        const { status, statusClass, analysis } = RankManager.analyzeRankStatus(winRate, totalGames, dataManager.currentRank);
        
        // 設定進度條寬度
        rankProgress.style.width = winRate + '%';
        
        // 更新狀態顯示
        rankStatusText.textContent = status;
        rankStatusText.className = statusClass;
        rankAnalysis.textContent = analysis;
        
        // 更新預測
        const prediction = RankManager.generatePredictions(
            wins, totalGames, winRate, 
            rank.maintain, rank.danger, dataManager.currentRank
        );
        rankPrediction.innerHTML = prediction;
    }

    // 新增對戰記錄
    addBattle() {
        const myClass = document.getElementById('myClass')?.value;
        const opponentClass = document.getElementById('opponentClass')?.value;
        const turnOrder = document.getElementById('turnOrder')?.value;
        const result = document.getElementById('result')?.value;
        const bpChangeInput = document.getElementById('bpChange');
        const bpValue = bpChangeInput?.value.replace(/^\+/, ''); // 移除前導+號
        const bpChange = parseInt(bpValue) || 0;
        
        // 驗證必填欄位
        if (!turnOrder) {
            alert('請選擇先手或後手！');
            document.getElementById('turnOrder')?.focus();
            return;
        }
        
        if (!result) {
            alert('請選擇對戰結果！');
            document.getElementById('result')?.focus();
            return;
        }
        
        if (bpChange === 0) {
            alert('請輸入BP變化值！');
            bpChangeInput?.focus();
            bpChangeInput?.classList.add('error');
            return;
        }
        
        // 驗證BP值範圍
        if (Math.abs(bpChange) > 1000) {
            const confirmMsg = `BP變化值 ${bpChange} 似乎很大，是否確認無誤？`;
            if (!confirm(confirmMsg)) {
                bpChangeInput?.focus();
                bpChangeInput?.select();
                return;
            }
        }
        
        const newBattle = {
            myClass,
            opponentClass,
            turnOrder,
            result,
            bpChange
        };
        
        dataManager.addBattle(newBattle);
        
        // 成功提示
        bpChangeInput?.classList.remove('error', 'warning');
        bpChangeInput?.classList.add('success');
        setTimeout(() => {
            bpChangeInput?.classList.remove('success');
        }, 1000);
        
        // 清空表單
        if (bpChangeInput) bpChangeInput.value = '';
        document.getElementById('turnOrder').value = '';
        document.getElementById('result').value = '';
        
        this.updateStats();
        this.renderBattles();
        
        // 顯示成功訊息
        this.showToast('對戰記錄已新增！', 'success');
    }

    // 編輯起始BP
    editStartingBP() {
        const newStartingBP = prompt('請輸入新的起始BP：', dataManager.startingBP);
        
        if (newStartingBP !== null && !isNaN(newStartingBP) && newStartingBP !== '') {
            const parsedBP = parseInt(newStartingBP);
            if (parsedBP >= 0) {
                dataManager.startingBP = parsedBP;
                dataManager.saveStartingBP();
                this.updateStats();
                
                // 添加視覺反饋
                const startingBPElement = document.getElementById('startingBP');
                if (startingBPElement) {
                    startingBPElement.style.transform = 'scale(1.1)';
                    startingBPElement.style.color = '#4CAF50';
                    setTimeout(() => {
                        startingBPElement.style.transform = 'scale(1)';
                        startingBPElement.style.color = '#ffd700';
                    }, 500);
                }
            } else {
                alert('BP不能為負數！');
            }
        }
    }

    // 編輯當前階級
    editCurrentRank() {
        const newRank = prompt(
            `請選擇目前分組：\n\n可選分組：\n🟢 綠寶石\n🟠 黃寶石\n🔴 紅寶石\n🔵 藍寶石\n💎 鑽石\n\n請輸入分組名稱（例：鑽石）：`,
            RANK_DATA[dataManager.currentRank].name
        );
        
        if (newRank !== null) {
            const rankKey = Object.keys(RANK_DATA).find(key => RANK_DATA[key].name === newRank.trim());
            if (rankKey) {
                dataManager.currentRank = rankKey;
                dataManager.saveCurrentRank();
                this.updateStats();
                
                // 添加視覺反饋
                const currentRankElement = document.getElementById('currentRank');
                if (currentRankElement) {
                    currentRankElement.style.transform = 'scale(1.1)';
                    currentRankElement.style.color = '#4CAF50';
                    setTimeout(() => {
                        currentRankElement.style.transform = 'scale(1)';
                        currentRankElement.style.color = '#ffd700';
                    }, 500);
                }
            } else {
                alert('請輸入正確的分組名稱！');
            }
        }
    }

    // 玩家資料編輯函數
    editPlayerName() {
        this.editPlayerField('name', '請輸入玩家名稱：', 'playerName');
    }

    editGameId() {
        this.editPlayerField('gameId', '請輸入遊戲ID：', 'gameId');
    }

    editMainClass() {
        const classes = Object.keys(CLASS_DATA);
        const newClass = prompt('請選擇主要職業：\n' + classes.join(', '), dataManager.playerData.mainClass);
        if (newClass !== null && classes.includes(newClass.trim())) {
            this.editPlayerField('mainClass', null, 'mainClass', newClass.trim());
        }
    }

    editTargetRank() {
        const ranks = Object.keys(RANK_DATA);
        const newRank = prompt('請選擇目標分組：\n' + ranks.join(', '), dataManager.playerData.targetRank);
        if (newRank !== null && ranks.includes(newRank.trim())) {
            this.editPlayerField('targetRank', null, 'targetRank', newRank.trim());
        }
    }

    // 通用玩家資料編輯
    editPlayerField(field, promptText, elementId, value = null) {
        const newValue = value || (promptText ? prompt(promptText, dataManager.playerData[field]) : null);
        if (newValue !== null && newValue.trim() !== '') {
            dataManager.playerData[field] = newValue.trim();
            this.updateElement(elementId, dataManager.playerData[field]);
            dataManager.savePlayerData();
            this.showSaveStatus('✅ 資料已自動保存', '#4caf50');
        }
    }

    // 玩家資料管理功能
    savePlayerProfile() {
        try {
            dataManager.savePlayerData();
            this.showSaveStatus('✅ 玩家資料已保存', '#4caf50');
            console.log('玩家資料保存成功');
        } catch (error) {
            this.showSaveStatus('❌ 保存失敗', '#f44336');
            console.error('玩家資料保存失敗:', error);
        }
    }

    resetPlayerProfile() {
        if (confirm('確定要重置所有玩家資料嗎？此操作無法復原！')) {
            try {
                // 重置玩家資料為預設值
                dataManager.playerData = { ...DEFAULT_PLAYER_DATA };
                dataManager.savePlayerData();
                this.initPlayerData(); // 重新載入顯示
                this.showSaveStatus('✅ 玩家資料已重置', '#ff9800');
                console.log('玩家資料重置成功');
            } catch (error) {
                this.showSaveStatus('❌ 重置失敗', '#f44336');
                console.error('玩家資料重置失敗:', error);
            }
        }
    }

    exportPlayerProfile() {
        try {
            const playerDataText = JSON.stringify(dataManager.playerData, null, 2);
            const exportContent = `# Shadowverse: Worlds Beyond - 玩家資料\n\n${playerDataText}`;
            
            const blob = new Blob([exportContent], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `shadowverse_player_profile_${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showSaveStatus('✅ 玩家資料已匯出', '#2196f3');
            console.log('玩家資料匯出成功');
        } catch (error) {
            this.showSaveStatus('❌ 匯出失敗', '#f44336');
            console.error('玩家資料匯出失敗:', error);
        }
    }

    // 編輯對戰記錄
    editBattle(battleId) {
        const battle = dataManager.getBattle(battleId);
        if (!battle) {
            this.showToast('找不到對戰記錄', 'error');
            return;
        }

        // 創建編輯對話框
        const dialogHtml = `
            <div style="background: #2a2a3e; padding: 20px; border-radius: 10px; color: white; max-width: 500px;">
                <h3 style="color: #ffd700; margin-top: 0;">編輯對戰記錄 #${battle.id}</h3>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin: 20px 0;">
                    <div>
                        <label style="display: block; margin-bottom: 5px;">我的職業：</label>
                        <select id="editMyClass" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="皇家" ${battle.myClass === '皇家' ? 'selected' : ''}>皇家</option>
                            <option value="精靈" ${battle.myClass === '精靈' ? 'selected' : ''}>精靈</option>
                            <option value="巫師" ${battle.myClass === '巫師' ? 'selected' : ''}>巫師</option>
                            <option value="龍" ${battle.myClass === '龍' ? 'selected' : ''}>龍</option>
                            <option value="夜魔" ${battle.myClass === '夜魔' ? 'selected' : ''}>夜魔</option>
                            <option value="主教" ${battle.myClass === '主教' ? 'selected' : ''}>主教</option>
                            <option value="復仇者" ${battle.myClass === '復仇者' ? 'selected' : ''}>復仇者</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px;">對手職業：</label>
                        <select id="editOpponentClass" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="皇家" ${battle.opponentClass === '皇家' ? 'selected' : ''}>皇家</option>
                            <option value="精靈" ${battle.opponentClass === '精靈' ? 'selected' : ''}>精靈</option>
                            <option value="巫師" ${battle.opponentClass === '巫師' ? 'selected' : ''}>巫師</option>
                            <option value="龍" ${battle.opponentClass === '龍' ? 'selected' : ''}>龍</option>
                            <option value="夜魔" ${battle.opponentClass === '夜魔' ? 'selected' : ''}>夜魔</option>
                            <option value="主教" ${battle.opponentClass === '主教' ? 'selected' : ''}>主教</option>
                            <option value="復仇者" ${battle.opponentClass === '復仇者' ? 'selected' : ''}>復仇者</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px;">先手/後手：</label>
                        <select id="editTurnOrder" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="" ${!battle.turnOrder ? 'selected' : ''}>未記錄</option>
                            <option value="先手" ${battle.turnOrder === '先手' ? 'selected' : ''}>先手</option>
                            <option value="後手" ${battle.turnOrder === '後手' ? 'selected' : ''}>後手</option>
                        </select>
                    </div>
                    
                    <div>
                        <label style="display: block; margin-bottom: 5px;">對戰結果：</label>
                        <select id="editResult" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                            <option value="勝" ${battle.result === '勝' ? 'selected' : ''}>勝</option>
                            <option value="敗" ${battle.result === '敗' ? 'selected' : ''}>敗</option>
                        </select>
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">BP變化：</label>
                    <input type="number" id="editBpChange" value="${battle.bpChange}" 
                           style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;" />
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                            style="padding: 8px 16px; margin-right: 10px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
                    <button onclick="saveEditBattle(${battleId})" 
                            style="padding: 8px 16px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">保存</button>
                </div>
            </div>
        `;
        
        this.showModal(dialogHtml);
    }

    // 刪除對戰記錄
    deleteBattle(battleId) {
        const battle = dataManager.getBattle(battleId);
        if (!battle) {
            this.showToast('找不到對戰記錄', 'error');
            return;
        }

        const confirmMessage = `確定要刪除以下對戰記錄嗎？\n\n` +
            `第${battle.id}場：${battle.myClass} vs ${battle.opponentClass} ` +
            `${battle.turnOrder || ''} ${battle.result} (${battle.bpChange > 0 ? '+' : ''}${battle.bpChange}BP)\n\n` +
            `注意：刪除後無法復原，相關的分組變動標記也會一併清除。`;

        if (confirm(confirmMessage)) {
            if (dataManager.deleteBattle(battleId)) {
                this.showToast('對戰記錄已刪除', 'success');
                this.updateStats();
                this.renderBattles();
                this.renderMatrix(); // 更新矩陣
            } else {
                this.showToast('刪除失敗', 'error');
            }
        }
    }

    // 顯示模態對話框
    showModal(content) {
        const modal = document.createElement('div');
        modal.style.cssText = `
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.7); display: flex; align-items: center; 
            justify-content: center; z-index: 10000;
        `;
        modal.innerHTML = content;
        document.body.appendChild(modal);
        
        // 點擊背景關閉
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                modal.remove();
            }
        });
    }

    // 切換分組變動標記
    toggleRankChange(battleIndex, battleId) {
        const existingChange = dataManager.rankChangeHistory.find(change => change.battleId === battleId);
        
        if (existingChange) {
            // 移除標記
            dataManager.removeRankChange(existingChange.id);
            this.showToast('已移除分組變動標記', 'info');
        } else {
            // 新增標記
            this.promptRankChange(battleIndex, battleId);
        }
        
        this.renderBattles();
    }

    // 提示輸入分組變動詳情
    promptRankChange(battleIndex, battleId) {
        const battle = dataManager.battleData[battleIndex];
        if (!battle) return;

        // 計算當時的統計數據
        const battlesTillNow = dataManager.battleData.slice(0, battleIndex + 1);
        const wins = battlesTillNow.filter(b => b.result === '勝').length;
        const totalGames = battlesTillNow.length;
        const winRate = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;

        const currentRank = dataManager.currentRank;
        
        // 讓用戶選擇變動前後的分組
        const rankOptions = ['綠寶石', '黃寶石', '紅寶石', '藍寶石', '鑽石'];
        
        let dialogHtml = `
            <div style="background: #2a2a3e; padding: 20px; border-radius: 10px; color: white; max-width: 400px;">
                <h3 style="color: #ffd700; margin-top: 0;">分組變動標記</h3>
                <p><strong>第${battleIndex + 1}場：</strong>${battle.myClass} vs ${battle.opponentClass} ${battle.turnOrder || ''} ${battle.result}</p>
                <p><strong>當時狀態：</strong>勝率 ${winRate}% (${wins}勝/${totalGames-wins}敗)</p>
                
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">變動前分組：</label>
                    <select id="fromRank" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                        ${rankOptions.map(rank => `<option value="${rank}" ${rank === currentRank ? 'selected' : ''}>${rank}</option>`).join('')}
                    </select>
                </div>
                
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">變動後分組：</label>
                    <select id="toRank" style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;">
                        ${rankOptions.map(rank => `<option value="${rank}">${rank}</option>`).join('')}
                    </select>
                </div>
                
                <div style="margin: 15px 0;">
                    <label style="display: block; margin-bottom: 5px;">變動原因：</label>
                    <input type="text" id="changeReason" placeholder="例如：連敗掉級、勝率回升升級等" 
                           style="width: 100%; padding: 8px; background: #1a1a2e; color: white; border: 1px solid #444; border-radius: 5px;" />
                </div>
                
                <div style="text-align: right; margin-top: 20px;">
                    <button onclick="this.parentElement.parentElement.parentElement.remove()" 
                            style="padding: 8px 16px; margin-right: 10px; background: #666; color: white; border: none; border-radius: 5px; cursor: pointer;">取消</button>
                    <button onclick="confirmRankChange(${battleIndex}, ${battleId})" 
                            style="padding: 8px 16px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer;">確認</button>
                </div>
            </div>
        `;
        
        // 創建模態對話框
        this.showModal(dialogHtml);
    }

    // 確認分組變動記錄
    confirmRankChange(battleIndex, battleId) {
        const fromRank = document.getElementById('fromRank').value;
        const toRank = document.getElementById('toRank').value;
        const reason = document.getElementById('changeReason').value || '手動標記';
        
        if (fromRank === toRank) {
            alert('變動前後分組相同，請重新選擇');
            return;
        }
        
        // 計算當時的統計數據
        const battlesTillNow = dataManager.battleData.slice(0, battleIndex + 1);
        const wins = battlesTillNow.filter(b => b.result === '勝').length;
        const totalGames = battlesTillNow.length;
        const winRate = totalGames > 0 ? Math.round((wins / totalGames) * 100) : 0;
        
        const changeRecord = dataManager.recordRankChange(battleIndex, fromRank, toRank, winRate, totalGames, reason);
        
        if (changeRecord) {
            uiController.showToast(`已標記分組變動：${fromRank} → ${toRank}`, 'success');
            uiController.renderBattles();
        }
        
        // 關閉對話框
        document.querySelector('[style*="position: fixed"]').remove();
    }

    // 匯出分組變動分析
    exportRankChangeAnalysis() {
        try {
            const analysisText = dataManager.exportRankChangeAnalysis();
            const blob = new Blob([analysisText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `shadowverse_rank_analysis_${new Date().toISOString().split('T')[0]}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showToast('分組變動分析已匯出', 'success');
        } catch (error) {
            this.showToast('匯出失敗：' + error.message, 'error');
        }
    }

    // 清除所有數據
    clearAllData() {
        if (confirm('確定要清除所有對戰數據嗎？此操作無法復原！')) {
            dataManager.clearAllBattles();
            this.updateStats();
            this.renderBattles();
        }
    }

    // 導出數據
    exportData() {
        const exportText = dataManager.exportData();
        const blob = new Blob([exportText], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `闇影詩章_凌越世界_對戰紀錄_${new Date().toISOString().split('T')[0]}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    }

    // 處理檔案匯入
    importFromFile(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const success = dataManager.parseImportData(e.target.result);
                if (success) {
                    this.updateStats();
                    this.renderBattles();
                    alert('數據匯入成功！');
                }
            } catch (error) {
                alert('匯入失敗：' + error.message);
            }
        };
        reader.readAsText(file, 'UTF-8');
    }

    // 綁定事件監聽器
    bindEvents() {
        // 結果變更自動建議BP值
        const resultSelect = document.getElementById('result');
        if (resultSelect) {
            resultSelect.addEventListener('change', (e) => {
                const result = e.target.value;
                const suggestedBP = result === '勝' ? CONFIG.DEFAULTS.WIN_BP : CONFIG.DEFAULTS.LOSE_BP;
                const bpChangeInput = document.getElementById('bpChange');
                if (bpChangeInput) {
                    bpChangeInput.placeholder = `建議值: +${suggestedBP}`;
                    bpChangeInput.value = suggestedBP;
                    // 自動選中輸入框內容，方便用戶修改
                    bpChangeInput.select();
                }
            });
        }

        // 先手後手選擇Enter鍵處理
        const turnOrderSelect = document.getElementById('turnOrder');
        if (turnOrderSelect) {
            turnOrderSelect.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // 移動焦點到結果選擇
                    document.getElementById('result')?.focus();
                }
            });
        }

        // 結果選擇Enter鍵處理
        if (resultSelect) {
            resultSelect.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    // 移動焦點到BP輸入框
                    document.getElementById('bpChange')?.focus();
                }
            });
        }

        // BP變化輸入框事件處理
        const bpChangeInput = document.getElementById('bpChange');
        if (bpChangeInput) {
            // Enter鍵提交功能
            bpChangeInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    this.addBattle();
                }
            });

            // 輸入驗證和錯誤修改支援
            bpChangeInput.addEventListener('input', (e) => {
                const value = e.target.value;
                const numValue = parseInt(value);
                
                // 移除之前的錯誤樣式
                e.target.classList.remove('error', 'warning');
                
                // 驗證輸入值
                if (value && isNaN(numValue)) {
                    e.target.classList.add('error');
                    e.target.title = '請輸入有效的數字';
                } else if (numValue && (numValue < -1000 || numValue > 1000)) {
                    e.target.classList.add('warning');
                    e.target.title = '數值似乎過大，請確認是否正確';
                } else {
                    e.target.title = '輸入BP變化值，按Enter提交';
                }
            });

            // 焦點事件處理
            bpChangeInput.addEventListener('focus', (e) => {
                // 獲得焦點時選中全部內容，方便修改
                setTimeout(() => e.target.select(), 0);
            });

            // 失去焦點時驗證
            bpChangeInput.addEventListener('blur', (e) => {
                const value = e.target.value;
                if (value && !isNaN(parseInt(value))) {
                    // 格式化數值顯示
                    const numValue = parseInt(value);
                    e.target.value = numValue > 0 ? `+${numValue}` : numValue.toString();
                }
            });
        }

        // 拖拽功能
        const importArea = document.getElementById('importArea');
        if (importArea) {
            importArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                importArea.classList.add('dragover');
            });
            
            importArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                importArea.classList.remove('dragover');
            });
            
            importArea.addEventListener('drop', (e) => {
                e.preventDefault();
                importArea.classList.remove('dragover');
                
                const files = e.dataTransfer.files;
                if (files.length > 0 && files[0].type === 'text/plain') {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const success = dataManager.parseImportData(event.target.result);
                            if (success) {
                                this.updateStats();
                                this.renderBattles();
                                alert('數據匯入成功！');
                            }
                        } catch (error) {
                            alert('匯入失敗：' + error.message);
                        }
                    };
                    reader.readAsText(files[0], 'UTF-8');
                } else {
                    alert('請拖放文字檔案(.txt)');
                }
            });
        }
    }

    // 輔助方法：更新元素內容
    updateElement(id, content) {
        const element = document.getElementById(id);
        if (element) {
            element.textContent = content;
        }
    }

    // 顯示Toast訊息
    showToast(message, type = 'info') {
        // 移除現有的toast
        const existingToast = document.querySelector('.toast');
        if (existingToast) {
            existingToast.remove();
        }

        // 創建新的toast
        const toast = document.createElement('div');
        toast.className = `toast toast-${type}`;
        toast.textContent = message;
        
        // 添加到頁面
        document.body.appendChild(toast);
        
        // 顯示動畫
        setTimeout(() => {
            toast.classList.add('show');
        }, 100);
        
        // 自動隱藏
        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 300);
        }, 3000);
    }

    // 顯示矩陣類型（先手/後手）
    showMatrixType(type) {
        // 切換按鈕狀態
        document.querySelectorAll('.matrix-btn').forEach(btn => {
            btn.classList.remove('active');
        });
        
        if (type === 'first') {
            document.getElementById('firstMatrixBtn').classList.add('active');
            document.getElementById('firstMatrix').classList.add('active');
            document.getElementById('secondMatrix').classList.remove('active');
        } else {
            document.getElementById('secondMatrixBtn').classList.add('active');
            document.getElementById('secondMatrix').classList.add('active');
            document.getElementById('firstMatrix').classList.remove('active');
        }
        
        this.renderMatrix();
    }

    // 渲染對戰矩陣
    renderMatrix() {
        const matrixData = dataManager.getMatrixStatistics();
        
        // 渲染先手矩陣
        this.renderMatrixTable('firstMatrixTable', matrixData.first, '先手');
        this.renderMatrixStats('firstMatrixStats', matrixData.first, '先手');
        
        // 渲染後手矩陣
        this.renderMatrixTable('secondMatrixTable', matrixData.second, '後手');
        this.renderMatrixStats('secondMatrixStats', matrixData.second, '後手');
    }

    // 渲染矩陣表格
    renderMatrixTable(tableId, matrixData, turnType) {
        const container = document.getElementById(tableId);
        if (!container) return;

        let html = '<table class="matrix-table-content">';
        
        // 表頭
        html += '<thead><tr><th class="matrix-header-corner">我方\\對手</th>';
        CLASS_LIST.forEach(opponentClass => {
            html += `<th class="matrix-header">${opponentClass}</th>`;
        });
        html += '</tr></thead>';
        
        // 表身
        html += '<tbody>';
        CLASS_LIST.forEach(myClass => {
            html += `<tr><td class="matrix-row-header">${myClass}</td>`;
            CLASS_LIST.forEach(opponentClass => {
                const data = matrixData[myClass][opponentClass];
                const winRate = data.winRate;
                const total = data.total;
                
                let cellClass = 'matrix-cell';
                let displayValue = '--';
                
                if (total > 0) {
                    displayValue = `${winRate}%`;
                    if (winRate >= 70) {
                        cellClass += ' high-winrate';
                    } else if (winRate >= 50) {
                        cellClass += ' medium-winrate';
                    } else {
                        cellClass += ' low-winrate';
                    }
                }
                
                html += `<td class="${cellClass}" title="${myClass} vs ${opponentClass} (${turnType}): ${data.wins}勝/${total}場">${displayValue}</td>`;
            });
            html += '</tr>';
        });
        html += '</tbody></table>';
        
        container.innerHTML = html;
    }

    // 渲染矩陣統計信息
    renderMatrixStats(statsId, matrixData, turnType) {
        const container = document.getElementById(statsId);
        if (!container) return;

        let totalGames = 0;
        let totalWins = 0;
        let bestMatchups = [];
        let worstMatchups = [];

        // 計算統計
        CLASS_LIST.forEach(myClass => {
            CLASS_LIST.forEach(opponentClass => {
                const data = matrixData[myClass][opponentClass];
                if (data.total > 0) {
                    totalGames += data.total;
                    totalWins += data.wins;
                    
                    if (data.total >= 3) { // 至少3場才納入最佳/最差統計
                        const matchup = {
                            vs: `${myClass} vs ${opponentClass}`,
                            winRate: data.winRate,
                            record: `${data.wins}勝/${data.total}場`
                        };
                        
                        if (data.winRate >= 70) {
                            bestMatchups.push(matchup);
                        } else if (data.winRate < 40) {
                            worstMatchups.push(matchup);
                        }
                    }
                }
            });
        });

        const overallWinRate = totalGames > 0 ? Math.round((totalWins / totalGames) * 100) : 0;
        
        // 排序
        bestMatchups.sort((a, b) => b.winRate - a.winRate);
        worstMatchups.sort((a, b) => a.winRate - b.winRate);

        let html = `
            <div class="matrix-stats-content">
                <h4>${turnType}整體統計</h4>
                <p>總場次：${totalGames}場 | 總勝率：${overallWinRate}%</p>
        `;

        if (bestMatchups.length > 0) {
            html += `
                <div class="matchup-section">
                    <h5 style="color: #4CAF50;">🔥 優勢對戰 (≥70%)</h5>
                    <ul>
            `;
            bestMatchups.slice(0, 5).forEach(matchup => {
                html += `<li>${matchup.vs}: ${matchup.winRate}% (${matchup.record})</li>`;
            });
            html += '</ul></div>';
        }

        if (worstMatchups.length > 0) {
            html += `
                <div class="matchup-section">
                    <h5 style="color: #F44336;">⚠️ 劣勢對戰 (<40%)</h5>
                    <ul>
            `;
            worstMatchups.slice(0, 5).forEach(matchup => {
                html += `<li>${matchup.vs}: ${matchup.winRate}% (${matchup.record})</li>`;
            });
            html += '</ul></div>';
        }

        html += '</div>';
        container.innerHTML = html;
    }
}

// 全域UI控制器實例
const uiController = new UIController();

// 全域函數（保持向後兼容）
function showPanel(panelName) {
    uiController.showPanel(panelName);
}

function addBattle() {
    uiController.addBattle();
}

function editStartingBP() {
    uiController.editStartingBP();
}

function editCurrentRank() {
    uiController.editCurrentRank();
}

function editPlayerName() {
    uiController.editPlayerName();
}

function editGameId() {
    uiController.editGameId();
}

function editMainClass() {
    uiController.editMainClass();
}

function editTargetRank() {
    uiController.editTargetRank();
}

function clearAllData() {
    uiController.clearAllData();
}

function exportData() {
    uiController.exportData();
}

function importFromFile(event) {
    uiController.importFromFile(event);
}

// 玩家資料管理全域函數
function savePlayerProfile() {
    uiController.savePlayerProfile();
}

function resetPlayerProfile() {
    uiController.resetPlayerProfile();
}

function exportPlayerProfile() {
    uiController.exportPlayerProfile();
}

// 矩陣管理全域函數
function showMatrixType(type) {
    uiController.showMatrixType(type);
}

// 分組變動管理全域函數
function toggleRankChange(battleIndex, battleId) {
    uiController.toggleRankChange(battleIndex, battleId);
}

function confirmRankChange(battleIndex, battleId) {
    uiController.confirmRankChange(battleIndex, battleId);
}

function exportRankChangeAnalysis() {
    uiController.exportRankChangeAnalysis();
}

// 對戰記錄編輯全域函數
function editBattle(battleId) {
    uiController.editBattle(battleId);
}

function deleteBattle(battleId) {
    uiController.deleteBattle(battleId);
}

function saveEditBattle(battleId) {
    console.log('Global saveEditBattle called with battleId:', battleId);
    try {
        uiController.saveEditBattle(battleId);
    } catch (error) {
        console.error('Error in global saveEditBattle:', error);
        alert('保存失敗：' + error.message);
    }
}


    </script>
    <script src="src/js/data-manager.js"></script>
    <script src="src/js/rank-manager.js"></script>
    <script src="src/js/ui-controller.js"></script>
    
    <!-- 初始化腳本 -->
    <script>
        // 確保所有模組載入後再初始化
        document.addEventListener('DOMContentLoaded', function() {
            console.log('應用程式正在初始化...');
            
            // 檢查必要的物件是否存在
            if (typeof dataManager === 'undefined') {
                console.error('DataManager 未載入！');
            }
            if (typeof rankManager === 'undefined') {
                console.error('RankManager 未載入！');
            }
            if (typeof uiController === 'undefined') {
                console.error('UIController 未載入！');
            }
            
            console.log('應用程式初始化完成！');
        });
    </script>
</body>
</html>

